#!/usr/bin/env bash
# security.sh - Security management CLI
# Part of nself v0.6.0 - Sprint 17: Advanced Security
#
# Commands:
#   nself security scan            - Scan for vulnerabilities
#   nself security devices         - List user devices
#   nself security mfa enable      - Enable MFA (delegates to mfa.sh)
#   nself security incidents       - View security incidents
#   nself security events          - View security events
#   nself security webauthn        - Manage WebAuthn/FIDO2 keys
#   nself security headers         - Manage security headers (CSP, HSTS, etc.)
#
# Usage: nself security <subcommand> [options]

set -euo pipefail

# Get script directory for sourcing dependencies
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
NSELF_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"

# Source dependencies
if ! declare -f log_error >/dev/null 2>&1; then
  source "$NSELF_ROOT/src/lib/utils/display.sh" 2>/dev/null || true
fi

# Constants
if [[ -z "${EXIT_SUCCESS:-}" ]]; then
  source "$NSELF_ROOT/src/lib/config/constants.sh" 2>/dev/null || true
fi

# ============================================================================
# Helper Functions
# ============================================================================

# Execute SQL query
exec_sql() {
  local query="$1"
  local db_name="${POSTGRES_DB:-nself_db}"
  local db_user="${POSTGRES_USER:-postgres}"

  docker exec -i "$(docker ps -qf name=postgres)" \
    psql -U "$db_user" -d "$db_name" -t -A -c "$query" 2>/dev/null || echo ""
}

# Execute SQL query and format as JSON
exec_sql_json() {
  local query="$1"
  local db_name="${POSTGRES_DB:-nself_db}"
  local db_user="${POSTGRES_USER:-postgres}"

  docker exec -i "$(docker ps -qf name=postgres)" \
    psql -U "$db_user" -d "$db_name" -t -A -c "$query" 2>/dev/null || echo "[]"
}

# Get current timestamp
get_timestamp() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

# ============================================================================
# Security Scanning
# ============================================================================

cmd_security_scan() {
  local scan_type="${1:-all}"

  case "$scan_type" in
    all)
      scan_weak_passwords
      scan_missing_mfa
      scan_expired_sessions
      scan_suspicious_activity
      ;;
    passwords)
      scan_weak_passwords
      ;;
    mfa)
      scan_missing_mfa
      ;;
    sessions)
      scan_expired_sessions
      ;;
    suspicious)
      scan_suspicious_activity
      ;;
    *)
      log_error "Unknown scan type: $scan_type"
      echo "Available types: all, passwords, mfa, sessions, suspicious"
      return 1
      ;;
  esac
}

scan_weak_passwords() {
  print_header "Weak Password Scan"

  local query="
    SELECT json_agg(json_build_object(
      'user_id', user_id,
      'email', email,
      'password_age_days', EXTRACT(DAY FROM password_age)::integer,
      'has_mfa', has_mfa
    ))
    FROM auth.get_weak_passwords();
  "

  local results
  results=$(exec_sql_json "$query")

  if [[ "$results" == "null" ]] || [[ "$results" == "[]" ]]; then
    print_success "No weak passwords detected"
    return 0
  fi

  local count
  count=$(echo "$results" | jq 'length')

  print_warning "Found $count users with weak password security:"
  echo ""

  echo "$results" | jq -r '.[] | "  \(.email)
    Password age: \(.password_age_days) days
    MFA enabled: \(if .has_mfa then "Yes" else "No" end)
  "'

  echo ""
  print_info "Recommendations:"
  echo "  - Reset passwords older than 90 days"
  echo "  - Enable MFA for all users: nself security mfa enable"
}

scan_missing_mfa() {
  print_header "MFA Status Scan"

  local query="
    SELECT json_agg(json_build_object(
      'user_id', u.id,
      'email', u.email,
      'role', u.role,
      'created_at', u.created_at
    ))
    FROM auth.users u
    WHERE NOT EXISTS (
      SELECT 1 FROM auth.mfa_factors
      WHERE user_id = u.id AND verified = true
    )
    AND u.email IS NOT NULL
    ORDER BY u.created_at DESC;
  "

  local results
  results=$(exec_sql_json "$query")

  if [[ "$results" == "null" ]] || [[ "$results" == "[]" ]]; then
    print_success "All users have MFA enabled"
    return 0
  fi

  local count
  count=$(echo "$results" | jq 'length')

  print_warning "Found $count users without MFA:"
  echo ""

  echo "$results" | jq -r '.[] | "  \(.email) (\(.role))"'

  echo ""
  print_info "Enable MFA: nself mfa enable --user=<user_id> --method=totp"
}

scan_expired_sessions() {
  print_header "Session Security Scan"

  # Sessions older than 30 days
  local query="
    SELECT COUNT(*)
    FROM auth.sessions
    WHERE created_at < NOW() - INTERVAL '30 days'
      AND NOT (metadata->>'is_persistent')::boolean;
  "

  local expired_count
  expired_count=$(exec_sql "$query" | tr -d ' ')

  if [[ "$expired_count" == "0" ]]; then
    print_success "No expired sessions found"
  else
    print_warning "Found $expired_count expired sessions"
    print_info "Clean up with: nself auth sessions cleanup"
  fi

  # Suspicious session activity
  local suspicious_query="
    SELECT COUNT(DISTINCT user_id)
    FROM auth.sessions
    WHERE created_at > NOW() - INTERVAL '1 hour'
    GROUP BY user_id
    HAVING COUNT(*) > 5;
  "

  local suspicious_count
  suspicious_count=$(exec_sql "$suspicious_query" | wc -l | tr -d ' ')

  if [[ "$suspicious_count" -gt "0" ]]; then
    print_warning "Found $suspicious_count users with unusual session activity"
  fi
}

scan_suspicious_activity() {
  print_header "Suspicious Activity Scan"

  local query="
    SELECT json_agg(json_build_object(
      'event_id', id,
      'event_type', event_type,
      'severity', severity,
      'user_id', user_id,
      'description', description,
      'risk_score', risk_score,
      'created_at', created_at
    ))
    FROM auth.security_events
    WHERE is_suspicious = true
      AND status = 'open'
      AND created_at > NOW() - INTERVAL '7 days'
    ORDER BY created_at DESC
    LIMIT 20;
  "

  local results
  results=$(exec_sql_json "$query")

  if [[ "$results" == "null" ]] || [[ "$results" == "[]" ]]; then
    print_success "No suspicious activity detected"
    return 0
  fi

  local count
  count=$(echo "$results" | jq 'length')

  print_warning "Found $count suspicious events in the last 7 days:"
  echo ""

  echo "$results" | jq -r '.[] | "  [\(.severity)] \(.event_type)
    \(.description)
    Risk: \(.risk_score)/100
    Time: \(.created_at)
  "'

  echo ""
  print_info "Review incidents: nself security incidents"
}

# ============================================================================
# Device Management
# ============================================================================

cmd_security_devices() {
  local action="${1:-list}"
  shift || true

  case "$action" in
    list)
      list_devices "$@"
      ;;
    trust)
      trust_device "$@"
      ;;
    untrust)
      untrust_device "$@"
      ;;
    remove)
      remove_device "$@"
      ;;
    *)
      log_error "Unknown devices action: $action"
      echo "Available actions: list, trust, untrust, remove"
      return 1
      ;;
  esac
}

list_devices() {
  local user_id="${1:-}"

  if [[ -z "$user_id" ]]; then
    log_error "User ID required. Use: nself security devices list <user_id>"
    return 1
  fi

  print_header "Devices for User: $user_id"

  local query="
    SELECT json_agg(json_build_object(
      'device_id', id,
      'device_name', device_name,
      'device_type', device_type,
      'os', os,
      'browser', browser,
      'is_trusted', is_trusted,
      'risk_score', risk_score,
      'last_seen', last_seen_at,
      'login_count', login_count
    ))
    FROM auth.user_devices
    WHERE user_id = '$user_id'::uuid
    ORDER BY last_seen_at DESC;
  "

  local results
  results=$(exec_sql_json "$query")

  if [[ "$results" == "null" ]] || [[ "$results" == "[]" ]]; then
    print_info "No devices found for this user"
    return 0
  fi

  echo "$results" | jq -r '.[] | "
Device: \(.device_name // "Unknown")
  ID: \(.device_id)
  Type: \(.device_type)
  OS: \(.os)
  Browser: \(.browser)
  Trusted: \(if .is_trusted then "Yes" else "No" end)
  Risk Score: \(.risk_score)/100
  Last Seen: \(.last_seen)
  Login Count: \(.login_count)
  "'
}

trust_device() {
  local device_id="${1:-}"

  if [[ -z "$device_id" ]]; then
    log_error "Device ID required. Use: nself security devices trust <device_id>"
    return 1
  fi

  local query="
    UPDATE auth.user_devices
    SET is_trusted = true, risk_score = 0
    WHERE id = '$device_id'::uuid;
  "

  exec_sql "$query" >/dev/null
  print_success "Device trusted: $device_id"
}

untrust_device() {
  local device_id="${1:-}"

  if [[ -z "$device_id" ]]; then
    log_error "Device ID required. Use: nself security devices untrust <device_id>"
    return 1
  fi

  local query="
    UPDATE auth.user_devices
    SET is_trusted = false
    WHERE id = '$device_id'::uuid;
  "

  exec_sql "$query" >/dev/null
  print_success "Device untrusted: $device_id"
}

remove_device() {
  local device_id="${1:-}"

  if [[ -z "$device_id" ]]; then
    log_error "Device ID required. Use: nself security devices remove <device_id>"
    return 1
  fi

  local query="
    DELETE FROM auth.user_devices
    WHERE id = '$device_id'::uuid;
  "

  exec_sql "$query" >/dev/null
  print_success "Device removed: $device_id"
}

# ============================================================================
# Security Incidents
# ============================================================================

cmd_security_incidents() {
  local action="${1:-list}"
  shift || true

  case "$action" in
    list)
      list_incidents "$@"
      ;;
    show)
      show_incident "$@"
      ;;
    create)
      create_incident "$@"
      ;;
    resolve)
      resolve_incident "$@"
      ;;
    *)
      log_error "Unknown incidents action: $action"
      echo "Available actions: list, show, create, resolve"
      return 1
      ;;
  esac
}

list_incidents() {
  local status="${1:-open}"

  print_header "Security Incidents ($status)"

  local query="
    SELECT json_agg(json_build_object(
      'id', id,
      'title', title,
      'severity', severity,
      'status', status,
      'priority', priority,
      'detected_at', detected_at,
      'assigned_to', assigned_to
    ))
    FROM auth.security_incidents
    WHERE status = '$status'
    ORDER BY detected_at DESC
    LIMIT 50;
  "

  local results
  results=$(exec_sql_json "$query")

  if [[ "$results" == "null" ]] || [[ "$results" == "[]" ]]; then
    print_info "No $status incidents found"
    return 0
  fi

  echo "$results" | jq -r '.[] | "
[\(.severity | ascii_upcase)] \(.title)
  ID: \(.id)
  Status: \(.status)
  Priority: \(.priority)
  Detected: \(.detected_at)
  "'
}

show_incident() {
  local incident_id="${1:-}"

  if [[ -z "$incident_id" ]]; then
    log_error "Incident ID required. Use: nself security incidents show <incident_id>"
    return 1
  fi

  local query="
    SELECT json_build_object(
      'id', id,
      'title', title,
      'description', description,
      'severity', severity,
      'category', category,
      'status', status,
      'priority', priority,
      'affected_user_ids', affected_user_ids,
      'detected_at', detected_at,
      'resolved_at', resolved_at,
      'resolution', resolution,
      'metadata', metadata
    )
    FROM auth.security_incidents
    WHERE id = '$incident_id'::uuid;
  "

  local result
  result=$(exec_sql_json "$query")

  if [[ "$result" == "null" ]]; then
    log_error "Incident not found: $incident_id"
    return 1
  fi

  echo "$result" | jq '.'
}

create_incident() {
  local title="${1:-}"
  local severity="${2:-medium}"
  local description="${3:-}"

  if [[ -z "$title" ]]; then
    log_error "Title required. Use: nself security incidents create <title> [severity] [description]"
    return 1
  fi

  local query="
    INSERT INTO auth.security_incidents (title, severity, description, category)
    VALUES ('$title', '$severity', '${description:-Manual incident}', 'manual')
    RETURNING id;
  "

  local incident_id
  incident_id=$(exec_sql "$query" | tr -d ' ')

  print_success "Incident created: $incident_id"
}

resolve_incident() {
  local incident_id="${1:-}"
  local resolution="${2:-Resolved manually}"

  if [[ -z "$incident_id" ]]; then
    log_error "Incident ID required. Use: nself security incidents resolve <incident_id> [resolution]"
    return 1
  fi

  local query="
    UPDATE auth.security_incidents
    SET status = 'resolved',
        resolution = '$resolution',
        resolved_at = NOW()
    WHERE id = '$incident_id'::uuid;
  "

  exec_sql "$query" >/dev/null
  print_success "Incident resolved: $incident_id"
}

# ============================================================================
# Security Events
# ============================================================================

cmd_security_events() {
  local user_id="${1:-}"
  local limit="${2:-20}"

  if [[ -z "$user_id" ]]; then
    # Show recent events for all users
    print_header "Recent Security Events (limit: $limit)"

    local query="
      SELECT json_agg(json_build_object(
        'event_type', event_type,
        'severity', severity,
        'description', description,
        'user_id', user_id,
        'is_suspicious', is_suspicious,
        'created_at', created_at
      ))
      FROM auth.security_events
      ORDER BY created_at DESC
      LIMIT $limit;
    "
  else
    # Show events for specific user
    print_header "Security Events for User: $user_id"

    local query="
      SELECT json_agg(json_build_object(
        'event_type', event_type,
        'severity', severity,
        'description', description,
        'is_suspicious', is_suspicious,
        'risk_score', risk_score,
        'ip_address', ip_address,
        'created_at', created_at
      ))
      FROM auth.security_events
      WHERE user_id = '$user_id'::uuid
      ORDER BY created_at DESC
      LIMIT $limit;
    "
  fi

  local results
  results=$(exec_sql_json "$query")

  if [[ "$results" == "null" ]] || [[ "$results" == "[]" ]]; then
    print_info "No security events found"
    return 0
  fi

  echo "$results" | jq -r '.[] | "
[\(.severity)] \(.event_type)
  \(.description)
  Suspicious: \(if .is_suspicious then "YES" else "No" end)
  Time: \(.created_at)
  "'
}

# ============================================================================
# WebAuthn/FIDO2 Management
# ============================================================================

cmd_security_webauthn() {
  local action="${1:-list}"
  shift || true

  case "$action" in
    list)
      list_webauthn_keys "$@"
      ;;
    add)
      log_warning "WebAuthn enrollment must be done through the web UI"
      log_info "Visit your profile security settings to add a hardware key"
      ;;
    remove)
      remove_webauthn_key "$@"
      ;;
    *)
      log_error "Unknown webauthn action: $action"
      echo "Available actions: list, add, remove"
      return 1
      ;;
  esac
}

list_webauthn_keys() {
  local user_id="${1:-}"

  if [[ -z "$user_id" ]]; then
    log_error "User ID required. Use: nself security webauthn list <user_id>"
    return 1
  fi

  print_header "WebAuthn Keys for User: $user_id"

  local query="
    SELECT json_agg(json_build_object(
      'id', id,
      'name', name,
      'credential_type', credential_type,
      'transports', transports,
      'authenticator_attachment', authenticator_attachment,
      'created_at', created_at,
      'last_used_at', last_used_at
    ))
    FROM auth.webauthn_credentials
    WHERE user_id = '$user_id'::uuid
    ORDER BY created_at DESC;
  "

  local results
  results=$(exec_sql_json "$query")

  if [[ "$results" == "null" ]] || [[ "$results" == "[]" ]]; then
    print_info "No WebAuthn keys found for this user"
    return 0
  fi

  echo "$results" | jq -r '.[] | "
Key: \(.name // "Unnamed")
  ID: \(.id)
  Type: \(.authenticator_attachment // "unknown")
  Transports: \(.transports | join(", "))
  Created: \(.created_at)
  Last Used: \(.last_used_at // "Never")
  "'
}

remove_webauthn_key() {
  local key_id="${1:-}"

  if [[ -z "$key_id" ]]; then
    log_error "Key ID required. Use: nself security webauthn remove <key_id>"
    return 1
  fi

  local query="
    DELETE FROM auth.webauthn_credentials
    WHERE id = '$key_id'::uuid;
  "

  exec_sql "$query" >/dev/null
  print_success "WebAuthn key removed: $key_id"
}

# ============================================================================
# MFA Shortcut
# ============================================================================

cmd_security_mfa() {
  log_info "Delegating to MFA CLI..."
  "$SCRIPT_DIR/mfa.sh" "$@"
}

# ============================================================================
# Help
# ============================================================================

security_usage() {
  cat <<EOF
Usage: nself security <subcommand> [options]

Security management and monitoring for nself

SUBCOMMANDS:
  scan              Scan for security vulnerabilities
  devices           Manage user devices
  mfa               Enable/manage MFA (delegates to nself mfa)
  incidents         View and manage security incidents
  events            View security event logs
  webauthn          Manage WebAuthn/FIDO2 hardware keys
  headers           Manage security headers (CSP, HSTS, etc.)

SCAN OPTIONS:
  all               Scan all security checks (default)
  passwords         Scan for weak passwords
  mfa               Scan for missing MFA
  sessions          Scan for expired/suspicious sessions
  suspicious        Scan for suspicious activity

DEVICE ACTIONS:
  list <user_id>              List all devices for user
  trust <device_id>           Mark device as trusted
  untrust <device_id>         Remove trusted status
  remove <device_id>          Remove device

INCIDENT ACTIONS:
  list [status]               List incidents (default: open)
  show <incident_id>          Show incident details
  create <title> [severity]   Create new incident
  resolve <incident_id>       Resolve incident

WEBAUTHN ACTIONS:
  list <user_id>              List WebAuthn keys for user
  remove <key_id>             Remove WebAuthn key

EXAMPLES:
  # Run full security scan
  nself security scan

  # Scan for weak passwords
  nself security scan passwords

  # List user devices
  nself security devices list <user_id>

  # Trust a device
  nself security devices trust <device_id>

  # View security incidents
  nself security incidents list

  # View security events for a user
  nself security events <user_id>

  # List WebAuthn keys
  nself security webauthn list <user_id>

  # Enable MFA (delegates to mfa.sh)
  nself security mfa enable --method=totp --user=<user_id>

For more information, visit: https://docs.nself.org/security
EOF
}

# ============================================================================
# Main Command Router
# ============================================================================

cmd_security() {
  local subcommand="${1:-}"

  if [[ -z "$subcommand" ]]; then
    security_usage
    exit 0
  fi

  shift

  case "$subcommand" in
    scan)
      cmd_security_scan "$@"
      ;;
    devices)
      cmd_security_devices "$@"
      ;;
    mfa)
      cmd_security_mfa "$@"
      ;;
    incidents)
      cmd_security_incidents "$@"
      ;;
    events)
      cmd_security_events "$@"
      ;;
    webauthn)
      cmd_security_webauthn "$@"
      ;;
    headers)
      cmd_security_headers "$@"
      ;;
    help|--help|-h)
      security_usage
      exit 0
      ;;
    *)
      log_error "Unknown subcommand: $subcommand"
      echo ""
      security_usage
      exit 1
      ;;
  esac
}

# ============================================================================
# Export command for main CLI dispatcher
# ============================================================================

# If executed directly (for testing)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  cmd_security "$@"
fi
