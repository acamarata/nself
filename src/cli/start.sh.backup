#!/usr/bin/env bash
# start.sh - Modular, maintainable start command for nself
# Bash 3.2 compatible, cross-platform
set -euo pipefail

# Get script directory (handle both sourced and executed cases)
if [[ -n "${BASH_SOURCE[0]}" ]]; then
  START_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
else
  # When called via bash script.sh, use $0
  START_SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
fi

# Source core utilities (these might change SCRIPT_DIR)
source "$START_SCRIPT_DIR/../lib/utils/display.sh"
source "$START_SCRIPT_DIR/../lib/utils/env.sh"
source "$START_SCRIPT_DIR/../lib/utils/hosts.sh" 2>/dev/null || true

# Source modular start components (use our saved directory)
source "$START_SCRIPT_DIR/../lib/start/pre-checks.sh"
source "$START_SCRIPT_DIR/../lib/start/docker-compose.sh"
source "$START_SCRIPT_DIR/../lib/start/docker-compose-simple.sh" 2>/dev/null || true
source "$START_SCRIPT_DIR/../lib/start/port-manager.sh"
source "$START_SCRIPT_DIR/../lib/start/auto-fix.sh" 2>/dev/null || true

# Parse command line options
parse_options() {
  VERBOSE=false
  DETACHED=true
  AUTO_FIX=true
  SKIP_CHECKS=false
  FORCE_REBUILD=false
  TARGET_ENV=""

  while [ $# -gt 0 ]; do
    case "$1" in
      --verbose|-v)
        VERBOSE=true
        shift
        ;;
      --attach|-a)
        DETACHED=false
        shift
        ;;
      --no-auto-fix)
        AUTO_FIX=false
        shift
        ;;
      --skip-checks)
        SKIP_CHECKS=true
        shift
        ;;
      --rebuild)
        FORCE_REBUILD=true
        shift
        ;;
      --dev|--development)
        TARGET_ENV="dev"
        shift
        ;;
      --staging|--stage)
        TARGET_ENV="staging"
        shift
        ;;
      --prod|--production)
        TARGET_ENV="prod"
        shift
        ;;
      --help|-h)
        show_help
        exit 0
        ;;
      *)
        log_error "Unknown option: $1"
        show_help
        exit 1
        ;;
    esac
  done
}

# Show help message
show_help() {
  cat << EOF
nself start - Start all services and infrastructure

Usage: nself start [OPTIONS]

Options:
  -v, --verbose       Show detailed output
  -a, --attach        Run in foreground (not detached)
  --no-auto-fix       Disable automatic port conflict resolution
  --skip-checks       Skip pre-flight checks
  --rebuild           Force rebuild of all containers
  -h, --help          Show this help message

Environment Options:
  --dev               Start in development environment (default)
  --staging           Start in staging environment
  --prod              Start in production environment

Examples:
  nself start                    # Start in dev environment
  nself start --staging          # Start in staging environment
  nself start --prod            # Start in production environment
  nself start --verbose          # Start with detailed output
  nself start --attach           # Start in foreground
  nself start --rebuild          # Rebuild and start all services

Environment Detection Priority:
  1. Command line flag (--dev, --staging, --prod)
  2. NSELF_ENV environment variable
  3. ENV in .env file
  4. Default: dev

EOF
}

# Main start function
main() {
  # Parse options
  parse_options "$@"

  # Show header
  show_command_header "nself start" "Start all services and infrastructure"

  # 1. Pre-flight checks
  if [ "$SKIP_CHECKS" = "false" ]; then
    if ! run_pre_checks "$VERBOSE"; then
      log_error "Pre-flight checks failed"
      exit 1
    fi
  fi

  # 2. Load environment with proper cascading
  # Detect target environment with priority:
  # 1. Command line flag (TARGET_ENV from parse_options)
  # 2. NSELF_ENV environment variable
  # 3. ENV from .env file
  # 4. Default to "dev"

  local target_env="${TARGET_ENV}"

  if [ -z "$target_env" ]; then
    if command -v detect_environment >/dev/null 2>&1; then
      target_env="$(detect_environment)"
      [ "$VERBOSE" = "true" ] && log_info "Detected environment: $target_env"
    else
      target_env="${NSELF_ENV:-${ENV:-dev}}"
    fi
  fi

  # Show which environment we're starting
  printf "\nStarting environment: \033[0;34m%s\033[0m\n" "$target_env"

  # Source env-merger if available (use START_SCRIPT_DIR)
  if [ -f "$START_SCRIPT_DIR/../lib/utils/env-merger.sh" ]; then
    source "$START_SCRIPT_DIR/../lib/utils/env-merger.sh"
  fi

  # Generate merged runtime environment
  if command -v merge_environments >/dev/null 2>&1; then
    printf "${COLOR_BLUE}⠋${COLOR_RESET} Merging environment configuration..."
    merge_environments "$target_env" ".env.runtime" > /dev/null 2>&1
    printf "\r${COLOR_GREEN}✓${COLOR_RESET} Environment configuration merged                \n"

    # Validate environment configuration
    if command -v validate_environment_config >/dev/null 2>&1; then
      if ! validate_environment_config "$target_env" ".env.runtime"; then
        log_error "Environment validation failed"
        exit 1
      fi
    fi

    # Load the runtime environment
    set -a
    source ".env.runtime"
    set +a

    [ "$VERBOSE" = "true" ] && log_info "Using merged runtime environment"
  else
    # Fallback to cascade_env_vars if available
    if command -v cascade_env_vars >/dev/null 2>&1; then
      cascade_env_vars "$target_env"
      [ "$VERBOSE" = "true" ] && log_info "Loaded cascaded environment for: $target_env"
    else
      # Final fallback to loading .env
      if [ -f ".env" ]; then
        set -a
        source ".env"
        set +a
        [ "$VERBOSE" = "true" ] && log_info "Loaded environment from .env"
      fi
    fi
  fi

  # Set the env_file for docker-compose (use runtime if available)
  local env_file=".env.runtime"
  [ ! -f "$env_file" ] && env_file=".env"

  # 3. Generate/Update SSL certificates for environment
  # Source auto-ssl if available (use START_SCRIPT_DIR)
  if [ -f "$START_SCRIPT_DIR/../lib/ssl/auto-ssl.sh" ]; then
    source "$START_SCRIPT_DIR/../lib/ssl/auto-ssl.sh"

    if command -v generate_ssl_for_environment >/dev/null 2>&1; then
      printf "${COLOR_BLUE}⠋${COLOR_RESET} Generating SSL certificates..."
      generate_ssl_for_environment "$target_env" "${BASE_DOMAIN:-localhost}" "ssl" "$env_file" > /dev/null 2>&1
      printf "\r${COLOR_GREEN}✓${COLOR_RESET} SSL certificates ready                        \n"
    fi
  fi

  # 4. Check and update hosts file
  ensure_hosts_entries "${BASE_DOMAIN:-localhost}" "${PROJECT_NAME:-nself}"

  # 4.5. Apply comprehensive auto-fixes for common issues
  printf "${COLOR_BLUE}⠋${COLOR_RESET} Applying auto-fixes..."
  if command -v apply_start_auto_fixes >/dev/null 2>&1; then
    apply_start_auto_fixes "${PROJECT_NAME:-nself}" "$env_file" "$VERBOSE"
    printf "\r${COLOR_GREEN}✓${COLOR_RESET} Auto-fixes applied                           \n"
  else
    printf "\r${COLOR_YELLOW}⚠${COLOR_RESET}  Auto-fix module not found                  \n"
  fi

  # 4. Handle port conflicts
  if [ "$AUTO_FIX" = "true" ]; then
    printf "${COLOR_BLUE}⠋${COLOR_RESET} Checking for port conflicts..."

    local port_result=$(auto_resolve_ports "$env_file")
    if [ "$port_result" = "ports_updated" ]; then
      printf "\r${COLOR_GREEN}✓${COLOR_RESET} Resolved port conflicts                      \n"
      # Show the updated ports if available
      if [ -n "${PORT_UPDATES:-}" ]; then
        echo ""
        echo "Updated ports:"
        printf "${PORT_UPDATES}"
        echo ""
      fi
      # Reload environment with new ports
      set -a
      source "$env_file"
      set +a
    else
      printf "\r✓ No port conflicts                            \n"
    fi
  fi

  # 5. Check if already running
  local running_count=$(check_existing_services)
  local expected_services=$(docker compose --project-name "${PROJECT_NAME:-nself}" --env-file "$env_file" config --services 2>/dev/null | wc -l | tr -d ' ')

  if [ $running_count -gt 0 ] && [ $running_count -eq $expected_services ]; then
    printf "\n${COLOR_GREEN}✓${COLOR_RESET} All %d services are already running\n\n" "$running_count"
    printf "Use ${COLOR_BLUE}nself status${COLOR_RESET} to view service status\n"
    printf "Use ${COLOR_BLUE}nself restart${COLOR_RESET} to restart services\n"
    printf "Use ${COLOR_BLUE}nself stop${COLOR_RESET} to stop services\n\n"
    exit 0
  elif [ $running_count -gt 0 ]; then
    printf "\n${COLOR_YELLOW}⚠${COLOR_RESET}  %d of %d services are running\n" "$running_count" "$expected_services"
    printf "${COLOR_BLUE}⠋${COLOR_RESET} Starting remaining services...\n"
  fi

  # 6. Docker network will be created by docker-compose
  # Remove any existing network that might conflict
  local network_name="${PROJECT_NAME:-nself}_network"
  if docker network ls --format "{{.Name}}" | grep -q "^${network_name}$"; then
    # Check if network is in use
    if ! docker network inspect "$network_name" --format '{{len .Containers}}' | grep -q "^0$" 2>/dev/null; then
      printf "${COLOR_YELLOW}⚠${COLOR_RESET}  Network $network_name in use by other containers\n"
    else
      # Remove unused network to let docker-compose recreate it
      docker network rm "$network_name" >/dev/null 2>&1 || true
    fi
  fi

  # 7. Pre-build services if needed
  if [ -f "$START_SCRIPT_DIR/../lib/start/pre-build.sh" ]; then
    source "$START_SCRIPT_DIR/../lib/start/pre-build.sh"
    # Don't fail if some services can't be built - they may use existing images
    pre_build_services "${PROJECT_NAME:-nself}" "$env_file" "$VERBOSE" || true
  fi

  # 8. Build and start services
  printf "${COLOR_BLUE}⠋${COLOR_RESET} Starting services..."

  # Determine build option - avoid building during up to prevent hangs
  local build_opt="false"  # Never build during up, we pre-built above

  # Build compose command - use runtime env file which has the merged environment
  local compose_cmd=$(build_compose_command "$env_file" "${PROJECT_NAME:-nself}" "$DETACHED" "$build_opt")

  # Use simple compose up to avoid hanging
  local compose_result
  if command -v simple_compose_up >/dev/null 2>&1; then
    simple_compose_up "${PROJECT_NAME:-nself}" "$env_file" "$VERBOSE"
    compose_result=$?
  else
    # Fallback to original method
    local timeout=300  # 5 minutes for initial startup with image pulls
    if [ $running_count -gt 0 ]; then
      timeout=120  # 2 minutes if some services are already running
    fi
    execute_compose_with_progress "$compose_cmd" "${PROJECT_NAME:-nself}" $timeout "$VERBOSE"
    compose_result=$?
  fi

  if [ $compose_result -eq 0 ]; then
    printf "\r${COLOR_GREEN}✓${COLOR_RESET} All services started                                    \n"
  elif [ $compose_result -eq 2 ]; then
    # Build failures detected, try without building
    if execute_compose_without_build "$env_file" "${PROJECT_NAME:-nself}" 300 "$VERBOSE"; then
      printf "\r${COLOR_YELLOW}✓${COLOR_RESET} Core services started (some custom services may need fixes) \n"
      printf "\n${COLOR_YELLOW}⚠${COLOR_RESET}  Custom service build issues detected\n"
      printf "  • Check ${COLOR_BLUE}services/${COLOR_RESET} directories for missing dependencies\n"
      printf "  • Run ${COLOR_BLUE}nself build --force${COLOR_RESET} to regenerate templates\n"
      printf "  • View logs: ${COLOR_BLUE}nself logs <service-name>${COLOR_RESET}\n\n"
    else
      printf "\r${COLOR_RED}✗${COLOR_RESET} Failed to start services                                \n\n"
      printf "${COLOR_RED}✗${COLOR_RESET} Check logs with: nself logs\n"
      exit 1
    fi
  else
    printf "\r${COLOR_RED}✗${COLOR_RESET} Failed to start services                                \n\n"
    printf "${COLOR_RED}✗${COLOR_RESET} Check logs with: nself logs\n"
    exit 1
  fi

  # 8. Wait for services to be healthy
  if check_services_health "${PROJECT_NAME:-nself}" 60; then
    # All services healthy - no additional message needed as check_services_health already printed it
    true
  else
    # 8.1. Attempt auto-healing
    if [ "$AUTO_FIX" = "true" ] && command -v monitor_and_heal_services >/dev/null 2>&1; then
      printf "${COLOR_BLUE}⠋${COLOR_RESET} Auto-healing unhealthy services..."
      monitor_and_heal_services "${PROJECT_NAME:-nself}" 3 "$VERBOSE"

      # Check health again after healing
      if check_services_health "${PROJECT_NAME:-nself}" 30; then
        # Services healed - check_services_health already printed success
        true
      else
        # Show detailed status of problematic services
        if command -v show_service_details >/dev/null 2>&1; then
          show_service_details "${PROJECT_NAME:-nself}" false
        fi

        echo ""
        printf "${COLOR_CYAN}Troubleshooting:${COLOR_RESET}\n"
        printf "  • View logs: ${COLOR_BLUE}nself logs <service-name>${COLOR_RESET}\n"
        printf "  • Restart service: ${COLOR_BLUE}docker compose restart <service-name>${COLOR_RESET}\n"
        printf "  • Check status: ${COLOR_BLUE}nself status${COLOR_RESET}\n"
        echo ""
      fi
    else
      # Show detailed status even without auto-fix
      if command -v show_service_details >/dev/null 2>&1; then
        show_service_details "${PROJECT_NAME:-nself}" false
      fi
    fi
  fi

  # 8.5. Run init containers (like minio bucket creation)
  if docker compose --project-name "${PROJECT_NAME:-nself}" --env-file "$env_file" --profile init run --rm minio-client >/dev/null 2>&1; then
    [ "$VERBOSE" = "true" ] && log_info "Init containers completed"
  fi

  # 9. Show service URLs
  echo ""
  show_service_urls
  echo ""

  # 10. Show next steps
  echo -e "${COLOR_CYAN}➞ Next Steps${COLOR_RESET}"
  echo ""
  echo -e "  ${COLOR_BLUE}nself urls${COLOR_RESET}    - View all service URLs"
  echo -e "  ${COLOR_BLUE}nself status${COLOR_RESET}  - View service status"
  echo -e "  ${COLOR_BLUE}nself logs${COLOR_RESET}    - View service logs"
  echo -e "  ${COLOR_BLUE}nself stop${COLOR_RESET}    - Stop all services"
  echo ""
}

# Show service URLs (simplified - full list via nself urls)
show_service_urls() {
  local base_domain="${BASE_DOMAIN:-localhost}"
  local protocol="http"
  [ "${SSL_ENABLED:-false}" = "true" ] && protocol="https"

  echo -e "${COLOR_CYAN}➞ Service URLs${COLOR_RESET}"
  echo ""

  # Show only the most important URLs
  echo -e "  Application:    $protocol://$base_domain"

  if [ "${HASURA_ENABLED:-true}" = "true" ]; then
    local hasura_route="${HASURA_ROUTE:-api.$base_domain}"
    echo -e "  GraphQL API:    $protocol://$hasura_route"
    echo -e "   - Console:     $protocol://$hasura_route/console"
  fi

  if [ "${AUTH_ENABLED:-true}" = "true" ]; then
    local auth_route="${AUTH_ROUTE:-auth.$base_domain}"
    echo -e "  Auth:           $protocol://$auth_route"
  fi

  if [ "${STORAGE_ENABLED:-false}" = "true" ]; then
    local storage_route="${STORAGE_ROUTE:-storage.$base_domain}"
    echo -e "  Storage:        $protocol://$storage_route"
  fi

  if [ "${GRAFANA_ENABLED:-false}" = "true" ]; then
    local grafana_route="${GRAFANA_ROUTE:-grafana.$base_domain}"
    echo -e "  Grafana:        $protocol://$grafana_route"
  fi

  echo ""
  echo -e "  ${COLOR_GRAY}Use 'nself urls' to see all ${COLOR_GREEN}$(count_enabled_services)${COLOR_GRAY} available routes${COLOR_RESET}"
}

# Helper to count enabled services with routes
count_enabled_services() {
  local count=1  # Application root

  # Count required services
  [ "${HASURA_ENABLED:-true}" = "true" ] && count=$((count + 1))
  [ "${AUTH_ENABLED:-true}" = "true" ] && count=$((count + 1))

  # Count optional services
  [ "${STORAGE_ENABLED:-false}" = "true" ] && count=$((count + 1))
  [ "${MINIO_ENABLED:-false}" = "true" ] && count=$((count + 1))
  [ "${MAILPIT_ENABLED:-false}" = "true" ] && count=$((count + 1))
  [ "${MEILISEARCH_ENABLED:-false}" = "true" ] && count=$((count + 1))
  [ "${GRAFANA_ENABLED:-false}" = "true" ] && count=$((count + 1))
  [ "${PROMETHEUS_ENABLED:-false}" = "true" ] && count=$((count + 1))
  [ "${NSELF_ADMIN_ENABLED:-false}" = "true" ] && count=$((count + 1))
  [ "${MLFLOW_ENABLED:-false}" = "true" ] && count=$((count + 1))

  # Count custom services
  for i in {1..10}; do
    local cs_var="CS_${i}"
    [ -n "${!cs_var:-}" ] && count=$((count + 1))
  done

  # Count frontend apps
  local frontend_count="${FRONTEND_APP_COUNT:-0}"
  count=$((count + frontend_count))

  echo "$count"
}

# Run main function
main "$@"