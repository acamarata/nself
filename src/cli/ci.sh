#!/usr/bin/env bash
# ci.sh - CI/CD Integration for nself
# Generate GitHub Actions workflows for nself projects

set -o pipefail

# Source shared utilities
CLI_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$CLI_SCRIPT_DIR/../lib/utils/env.sh" 2>/dev/null || true
source "$CLI_SCRIPT_DIR/../lib/utils/display.sh" 2>/dev/null || true

# Fallback logging
if ! declare -f log_success >/dev/null 2>&1; then
  log_success() { printf "\033[0;32m[SUCCESS]\033[0m %s\n" "$1"; }
fi
if ! declare -f log_warning >/dev/null 2>&1; then
  log_warning() { printf "\033[0;33m[WARNING]\033[0m %s\n" "$1"; }
fi
if ! declare -f log_error >/dev/null 2>&1; then
  log_error() { printf "\033[0;31m[ERROR]\033[0m %s\n" "$1" >&2; }
fi
if ! declare -f log_info >/dev/null 2>&1; then
  log_info() { printf "\033[0;34m[INFO]\033[0m %s\n" "$1"; }
fi

# ============================================================================
# TEMPLATE PATHS
# ============================================================================

TEMPLATE_DIR="${NSELF_ROOT:-/usr/local/lib/nself}/templates/ci"

# Fallback for development
if [[ ! -d "$TEMPLATE_DIR" ]]; then
  TEMPLATE_DIR="$CLI_SCRIPT_DIR/../templates/ci"
fi

# ============================================================================
# INITIALIZATION
# ============================================================================

cmd_init() {
  local provider="${1:-github}"

  log_info "Initializing CI/CD for provider: $provider"

  # Load project config
  [[ -f ".env" ]] && source ".env" 2>/dev/null || true

  local project_name="${PROJECT_NAME:-$(basename "$PWD")}"

  case "$provider" in
    github | github-actions)
      init_github_actions "$project_name"
      ;;
    gitlab)
      init_gitlab_ci "$project_name"
      ;;
    *)
      log_error "Unknown CI provider: $provider"
      log_info "Supported: github, gitlab"
      return 1
      ;;
  esac
}

init_github_actions() {
  local project_name="$1"

  log_info "Setting up GitHub Actions..."

  # Create workflows directory
  mkdir -p .github/workflows

  # Check if template exists
  local template="$TEMPLATE_DIR/github-actions/nself-ci.yml"

  if [[ -f "$template" ]]; then
    # Copy and customize template
    sed "s/{{PROJECT_NAME}}/$project_name/g" "$template" >.github/workflows/nself-ci.yml
  else
    # Generate inline
    generate_github_workflow "$project_name"
  fi

  log_success "Created .github/workflows/nself-ci.yml"

  echo ""
  log_info "Next steps:"
  echo ""
  echo "  1. Add GitHub Secrets for your servers:"
  echo "     - STAGING_HOST     (staging server hostname)"
  echo "     - STAGING_USER     (SSH username)"
  echo "     - STAGING_SSH_KEY  (SSH private key)"
  echo "     - PROD_HOST        (production server hostname)"
  echo "     - PROD_USER        (SSH username)"
  echo "     - PROD_SSH_KEY     (SSH private key)"
  echo ""
  echo "  2. Configure GitHub Environments:"
  echo "     - staging (auto-deploy on push to main)"
  echo "     - production (deploy on release)"
  echo ""
  echo "  3. Commit and push:"
  echo "     git add .github/workflows/"
  echo "     git commit -m 'Add CI/CD workflow'"
  echo "     git push"
  echo ""
}

generate_github_workflow() {
  local project_name="$1"

  cat >.github/workflows/nself-ci.yml <<EOF
# nself CI/CD Pipeline
# Generated by: nself ci init

name: nself CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [published]

env:
  PROJECT_NAME: $project_name

jobs:
  build:
    name: Build & Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test -- --passWithNoTests

  docker-test:
    name: Docker Build Test
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4

      - name: Create test env
        run: |
          cp .env.example .env 2>/dev/null || cat > .env << 'ENVEOF'
          PROJECT_NAME=$project_name
          ENV=test
          BASE_DOMAIN=localhost
          POSTGRES_PASSWORD=test-password
          HASURA_GRAPHQL_ADMIN_SECRET=test-secret
          ENVEOF

      - name: Install nself
        run: |
          curl -fsSL https://raw.githubusercontent.com/acamarata/nself/main/install.sh | bash
          echo "\$HOME/.local/bin" >> \$GITHUB_PATH

      - name: Build & validate
        run: |
          nself build
          docker compose config

  deploy-staging:
    name: Deploy Staging
    runs-on: ubuntu-latest
    needs: [build, docker-test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - name: Deploy
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: \${{ secrets.STAGING_HOST }}
          username: \${{ secrets.STAGING_USER }}
          key: \${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /var/www/$project_name
            git pull origin main
            nself update || true
            nself build
            nself restart

  deploy-production:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs: [build, docker-test]
    if: github.event_name == 'release'
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Backup & Deploy
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: \${{ secrets.PROD_HOST }}
          username: \${{ secrets.PROD_USER }}
          key: \${{ secrets.PROD_SSH_KEY }}
          script: |
            cd /var/www/$project_name
            nself db backup create pre-deploy
            git fetch --tags
            git checkout \${{ github.event.release.tag_name }}
            nself build
            nself restart
            nself db migrate up || true
EOF
}

init_gitlab_ci() {
  local project_name="$1"

  log_info "Setting up GitLab CI..."

  cat >.gitlab-ci.yml <<EOF
# nself GitLab CI/CD Pipeline
# Generated by: nself ci init

stages:
  - build
  - test
  - deploy

variables:
  PROJECT_NAME: $project_name
  NODE_VERSION: "20"

# Build & Test
build:
  stage: build
  image: node:\${NODE_VERSION}
  script:
    - npm ci
    - npm test -- --passWithNoTests
  cache:
    paths:
      - node_modules/

# Docker test
docker-test:
  stage: test
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - apk add --no-cache bash curl
    - curl -fsSL https://raw.githubusercontent.com/acamarata/nself/main/install.sh | bash
  script:
    - cp .env.example .env || echo "PROJECT_NAME=$project_name" > .env
    - nself build
    - docker compose config

# Deploy to staging
deploy-staging:
  stage: deploy
  environment:
    name: staging
  only:
    - main
  script:
    - |
      ssh \$STAGING_USER@\$STAGING_HOST << 'EOF'
        cd /var/www/$project_name
        git pull origin main
        nself update || true
        nself build
        nself restart
EOF

  # Deploy to production
  deploy-production:
  stage: deploy
  environment:
  name: production
  only:
  - tags
  when: manual
  script:
  - |
    # shellcheck disable=SC2259
    # Heredoc after pipe is valid syntax for ssh
    ssh \$PROD_USER@\$PROD_HOST <<'EOF'
        cd /var/www/$project_name
        nself db backup create pre-deploy
        git fetch --tags
        git checkout \$CI_COMMIT_TAG
        nself build
        nself restart
        nself db migrate up || true
EOF
  EOF

  log_success "Created .gitlab-ci.yml"

  echo ""
  log_info "Next steps:"
  echo "  1. Add CI/CD variables in GitLab Settings > CI/CD > Variables"
  echo "  2. Configure environments in Settings > Environments"
  echo "  3. Commit and push"
}

# ============================================================================
# STATUS & VALIDATION
# ============================================================================

cmd_status() {
  log_info "CI/CD Configuration Status"
  echo ""

  # Check GitHub Actions
  if [[ -d ".github/workflows" ]]; then
    log_success "GitHub Actions: Configured"
    for workflow in .github/workflows/*.yml; do
      [[ -f "$workflow" ]] && echo "  - $(basename "$workflow")"
    done
  else
    log_info "GitHub Actions: Not configured"
  fi

  # Check GitLab CI
  if [[ -f ".gitlab-ci.yml" ]]; then
    log_success "GitLab CI: Configured"
  else
    log_info "GitLab CI: Not configured"
  fi

  # Check for required secrets documentation
  echo ""
  log_info "Required Secrets:"
  echo "  STAGING_HOST      - Staging server hostname"
  echo "  STAGING_USER      - SSH username for staging"
  echo "  STAGING_SSH_KEY   - SSH private key for staging"
  echo "  PROD_HOST         - Production server hostname"
  echo "  PROD_USER         - SSH username for production"
  echo "  PROD_SSH_KEY      - SSH private key for production"
}

cmd_validate() {
  log_info "Validating CI/CD configuration..."

  local errors=0

  # Check GitHub Actions syntax
  if [[ -d ".github/workflows" ]]; then
    for workflow in .github/workflows/*.yml; do
      [[ -f "$workflow" ]] || continue

      # Basic YAML validation
      if command -v python3 >/dev/null 2>&1; then
        if python3 -c "import yaml; yaml.safe_load(open('$workflow'))" 2>/dev/null; then
          log_success "$(basename "$workflow"): Valid YAML"
        else
          log_error "$(basename "$workflow"): Invalid YAML"
          errors=$((errors + 1))
        fi
      else
        # Fallback: check for common issues
        if grep -q "^name:" "$workflow" && grep -q "^on:" "$workflow" && grep -q "^jobs:" "$workflow"; then
          log_success "$(basename "$workflow"): Basic structure OK"
        else
          log_warning "$(basename "$workflow"): May have structural issues"
        fi
      fi
    done
  fi

  # Check GitLab CI syntax
  if [[ -f ".gitlab-ci.yml" ]]; then
    if command -v python3 >/dev/null 2>&1; then
      if python3 -c "import yaml; yaml.safe_load(open('.gitlab-ci.yml'))" 2>/dev/null; then
        log_success ".gitlab-ci.yml: Valid YAML"
      else
        log_error ".gitlab-ci.yml: Invalid YAML"
        errors=$((errors + 1))
      fi
    fi
  fi

  echo ""
  if [[ $errors -eq 0 ]]; then
    log_success "Validation passed"
    return 0
  else
    log_error "Validation failed with $errors error(s)"
    return 1
  fi
}

# ============================================================================
# HELP
# ============================================================================

show_help() {
  cat <<'EOF'
nself ci - CI/CD Integration

USAGE:
  nself ci <command> [options]

COMMANDS:
  init [provider]     Initialize CI/CD configuration
                      Providers: github (default), gitlab

  status              Show CI/CD configuration status
  validate            Validate CI/CD configuration files

EXAMPLES:
  # Initialize GitHub Actions
  nself ci init

  # Initialize GitLab CI
  nself ci init gitlab

  # Check status
  nself ci status

  # Validate configuration
  nself ci validate

WORKFLOW FEATURES:
  • Build and test on push/PR
  • Deploy to staging on merge to main
  • Deploy to production on release tags
  • Automatic database backups before deploy
  • Rollback on deployment failure

REQUIRED SECRETS:
  For deployment to work, configure these secrets in your CI provider:

  STAGING_HOST        Staging server hostname
  STAGING_USER        SSH username for staging
  STAGING_SSH_KEY     SSH private key for staging
  PROD_HOST           Production server hostname
  PROD_USER           SSH username for production
  PROD_SSH_KEY        SSH private key for production

EOF
}

# ============================================================================
# MAIN
# ============================================================================

main() {
  local command="${1:-help}"
  shift || true

  case "$command" in
    init)
      cmd_init "$@"
      ;;
    status)
      cmd_status
      ;;
    validate)
      cmd_validate
      ;;
    help | --help | -h)
      show_help
      ;;
    *)
      log_error "Unknown command: $command"
      echo ""
      show_help
      return 1
      ;;
  esac
}

main "$@"
