#!/usr/bin/env bash
set -euo pipefail

# staging.sh - Staging environment management
# Mirror of production with staging-specific features like data seeding and reset

# Source shared utilities
SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
LIB_DIR="$SCRIPT_DIR/../lib"

source "$LIB_DIR/utils/display.sh"
source "$LIB_DIR/utils/env.sh"
source "$LIB_DIR/utils/platform-compat.sh" 2>/dev/null || true

# Source env and deploy modules
source "$LIB_DIR/env/create.sh" 2>/dev/null || true
source "$LIB_DIR/env/switch.sh" 2>/dev/null || true
source "$LIB_DIR/deploy/ssh.sh" 2>/dev/null || true
source "$LIB_DIR/deploy/health-check.sh" 2>/dev/null || true

# Main command function
cmd_staging() {
  local subcommand="${1:-status}"
  shift 2>/dev/null || true

  case "$subcommand" in
    init)
      staging_init "$@"
      ;;
    status)
      staging_status "$@"
      ;;
    deploy)
      staging_deploy "$@"
      ;;
    reset)
      staging_reset "$@"
      ;;
    seed)
      staging_seed "$@"
      ;;
    sync)
      staging_sync "$@"
      ;;
    logs)
      staging_logs "$@"
      ;;
    shell|ssh)
      staging_shell "$@"
      ;;
    --help|-h|help)
      show_staging_help
      ;;
    *)
      log_error "Unknown subcommand: $subcommand"
      printf "\n"
      show_staging_help
      return 1
      ;;
  esac
}

# Initialize staging environment
staging_init() {
  local domain="${1:-}"
  local email="${2:-}"

  # Parse additional arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --email)
        email="$2"
        shift 2
        ;;
      --server)
        local server="$2"
        shift 2
        ;;
      --force|-f)
        local force="true"
        shift
        ;;
      *)
        if [[ -z "$domain" ]]; then
          domain="$1"
        elif [[ -z "$email" ]]; then
          email="$1"
        fi
        shift
        ;;
    esac
  done

  show_command_header "nself staging init" "Initialize staging environment"

  if [[ -z "$domain" ]]; then
    log_error "Domain is required"
    printf "Usage: nself staging init <domain> [--email <email>] [--server <host>]\n"
    return 1
  fi

  log_info "Initializing staging environment for: $domain"

  # Create staging environment using env library
  if command -v env::create >/dev/null 2>&1; then
    env::create "staging" "staging" "${force:-false}"
  else
    # Fallback manual creation
    mkdir -p ".environments/staging"
  fi

  # Configure staging environment
  local env_dir=".environments/staging"
  local env_file="$env_dir/.env"

  cat > "$env_file" <<EOF
# Staging Environment Configuration
# Generated by nself staging init on $(date +%Y-%m-%d)

# Environment Settings
ENV=staging
DEBUG=false
LOG_LEVEL=info

# Domain Configuration
BASE_DOMAIN=$domain

# SSL Configuration
SSL_ENABLED=true
SSL_PROVIDER=letsencrypt
EOF

  if [[ -n "$email" ]]; then
    printf "SSL_EMAIL=%s\n" "$email" >> "$env_file"
  fi

  cat >> "$env_file" <<EOF

# Core Services
POSTGRES_ENABLED=true
HASURA_ENABLED=true
AUTH_ENABLED=true
NGINX_ENABLED=true

# Optional Services (staging defaults)
REDIS_ENABLED=true
MINIO_ENABLED=true
MAILPIT_ENABLED=true

# Monitoring (recommended for staging)
MONITORING_ENABLED=true

# Database Configuration
POSTGRES_DB=\${PROJECT_NAME:-myproject}_staging
POSTGRES_USER=postgres
# POSTGRES_PASSWORD set in .env.secrets

# Staging-specific settings
HASURA_GRAPHQL_DEV_MODE=false
HASURA_GRAPHQL_ENABLE_CONSOLE=true
EOF

  # Create server.json
  local server_file="$env_dir/server.json"
  cat > "$server_file" <<EOF
{
  "name": "staging",
  "type": "staging",
  "host": "${server:-}",
  "port": 22,
  "user": "",
  "key": "",
  "description": "Staging environment server"
}
EOF

  # Create empty secrets file
  local secrets_file="$env_dir/.env.secrets"
  cat > "$secrets_file" <<EOF
# Staging Secrets - DO NOT COMMIT TO VERSION CONTROL
# Generated by nself staging init on $(date +%Y-%m-%d)

# Database
POSTGRES_PASSWORD=

# Security Secrets
HASURA_GRAPHQL_ADMIN_SECRET=
JWT_SECRET=
COOKIE_SECRET=

# Service API Keys
MINIO_ROOT_PASSWORD=
REDIS_PASSWORD=
EOF

  chmod 600 "$secrets_file"

  log_success "Staging environment initialized"
  printf "\n"
  printf "Created:\n"
  printf "  %s/.env           - Environment configuration\n" "$env_dir"
  printf "  %s/server.json    - Server configuration\n" "$env_dir"
  printf "  %s/.env.secrets   - Secrets (edit this file)\n" "$env_dir"
  printf "\n"
  printf "Next steps:\n"
  printf "  1. Edit %s/server.json with your staging server details\n" "$env_dir"
  printf "  2. Generate secrets:  nself staging secrets generate\n"
  printf "  3. Switch environment: nself env switch staging\n"
  printf "  4. Deploy:             nself staging deploy\n"
  printf "\n"

  return 0
}

# Show staging status
staging_status() {
  show_command_header "nself staging status" "Staging environment status"

  # Check if staging environment exists
  local env_dir=".environments/staging"

  if [[ ! -d "$env_dir" ]]; then
    log_warning "Staging environment not found"
    printf "\n"
    printf "Initialize with: nself staging init <domain>\n"
    return 1
  fi

  # Check local configuration
  printf "${COLOR_CYAN}Local Configuration${COLOR_RESET}\n"
  printf "  Environment dir: %s\n" "$env_dir"

  if [[ -f "$env_dir/.env" ]]; then
    printf "  .env:           ${COLOR_GREEN}present${COLOR_RESET}\n"
    local domain
    domain=$(grep "^BASE_DOMAIN=" "$env_dir/.env" 2>/dev/null | cut -d'=' -f2 || echo "not set")
    printf "  Domain:         %s\n" "$domain"
  else
    printf "  .env:           ${COLOR_YELLOW}missing${COLOR_RESET}\n"
  fi

  if [[ -f "$env_dir/.env.secrets" ]]; then
    printf "  .env.secrets:   ${COLOR_GREEN}present${COLOR_RESET}\n"
  else
    printf "  .env.secrets:   ${COLOR_YELLOW}missing${COLOR_RESET}\n"
  fi

  # Check server configuration
  printf "\n${COLOR_CYAN}Server Configuration${COLOR_RESET}\n"
  if [[ -f "$env_dir/server.json" ]]; then
    local host user
    host=$(grep '"host"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    user=$(grep '"user"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)

    if [[ -n "$host" ]]; then
      printf "  Host:           %s\n" "$host"
      printf "  User:           %s\n" "${user:-<not set>}"

      # Test connection if ssh module available
      if command -v ssh::test_connection >/dev/null 2>&1 && [[ -n "$host" ]]; then
        printf "  Connection:     "
        if ssh::test_connection "$host" "${user:-root}" 2>/dev/null; then
          printf "${COLOR_GREEN}OK${COLOR_RESET}\n"
        else
          printf "${COLOR_RED}FAILED${COLOR_RESET}\n"
        fi
      fi
    else
      printf "  Host:           ${COLOR_YELLOW}<not configured>${COLOR_RESET}\n"
    fi
  else
    printf "  server.json:    ${COLOR_YELLOW}missing${COLOR_RESET}\n"
  fi

  # Check remote status if accessible
  if command -v health::check_deployment >/dev/null 2>&1 && [[ -n "${host:-}" ]]; then
    printf "\n${COLOR_CYAN}Remote Status${COLOR_RESET}\n"
    local deploy_path="/opt/nself"
    health::check_deployment "$host" "$deploy_path" "${user:-root}" 2>/dev/null || true
  fi

  return 0
}

# Deploy to staging
staging_deploy() {
  local dry_run=""
  local force=""
  local exclude_frontends=""

  while [[ $# -gt 0 ]]; do
    case $1 in
      --dry-run) dry_run="true"; shift ;;
      --force|-f) force="true"; shift ;;
      --exclude-frontends|--backend-only) exclude_frontends="true"; shift ;;
      *) shift ;;
    esac
  done

  show_command_header "nself staging deploy" "Deploy to staging environment"

  # ═══════════════════════════════════════════════════════════════
  # STAGING DEPLOYMENT: Full Stack (including Frontend Apps)
  # ═══════════════════════════════════════════════════════════════
  #
  # Staging deploys EVERYTHING by default to create a complete replica:
  #   - Core Services (4):     PostgreSQL, Hasura, Auth, Nginx
  #   - Optional Services (7): Based on *_ENABLED vars
  #   - Monitoring Bundle (10): If MONITORING_ENABLED=true
  #   - Custom Services (CS_N): User APIs, workers, remote schemas
  #   - Frontend Apps:         Nginx serves all frontend apps
  #
  # This differs from Production where frontends are external (Vercel, etc.)
  # Use --exclude-frontends to skip frontend apps if needed
  # ═══════════════════════════════════════════════════════════════

  printf "\n${COLOR_CYAN}Deployment Scope:${COLOR_RESET}\n"
  printf "  ${COLOR_GREEN}✓${COLOR_RESET} Core Services      (PostgreSQL, Hasura, Auth, Nginx)\n"
  printf "  ${COLOR_GREEN}✓${COLOR_RESET} Optional Services  (based on *_ENABLED vars)\n"
  printf "  ${COLOR_GREEN}✓${COLOR_RESET} Monitoring Bundle  (if MONITORING_ENABLED=true)\n"
  printf "  ${COLOR_GREEN}✓${COLOR_RESET} Custom Services    (CS_1, CS_2, ... remote schemas, APIs)\n"
  if [[ "$exclude_frontends" != "true" ]]; then
    printf "  ${COLOR_GREEN}✓${COLOR_RESET} Frontend Apps      (FRONTEND_APP_N - served by Nginx)\n"
  else
    printf "  ${COLOR_YELLOW}○${COLOR_RESET} Frontend Apps      (excluded with --exclude-frontends)\n"
  fi
  printf "\n"

  local env_dir=".environments/staging"

  if [[ ! -d "$env_dir" ]]; then
    log_error "Staging environment not configured"
    printf "Run: nself staging init <domain>\n"
    return 1
  fi

  # Get server details
  local host user port key_file deploy_path
  if [[ -f "$env_dir/server.json" ]]; then
    host=$(grep '"host"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    user=$(grep '"user"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    port=$(grep '"port"' "$env_dir/server.json" 2>/dev/null | grep -oE '[0-9]+' | head -1)
    key_file=$(grep '"key"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
  fi

  if [[ -z "$host" ]]; then
    log_error "Staging server not configured"
    printf "Edit: %s/server.json\n" "$env_dir"
    return 1
  fi

  user="${user:-root}"
  port="${port:-22}"
  deploy_path="${STAGING_DEPLOY_PATH:-/opt/nself}"

  log_info "Deploying to staging server: $host"
  printf "  User: %s\n" "$user"
  printf "  Path: %s\n" "$deploy_path"

  if [[ "$dry_run" == "true" ]]; then
    log_warning "DRY RUN - No actual deployment"
    printf "\n"
    printf "Would execute:\n"
    printf "  1. Test SSH connection to %s\n" "$host"
    printf "  2. Build locally (nself build)\n"
    printf "  3. Sync all files to %s:%s\n" "$host" "$deploy_path"
    if [[ "$exclude_frontends" != "true" ]]; then
      printf "  4. Sync frontend apps (served by Nginx)\n"
    fi
    printf "  5. Copy secrets (.env.secrets)\n"
    printf "  6. Run docker compose up -d\n"
    printf "  7. Verify deployment health\n"
    return 0
  fi

  # Test connection
  printf "\n  Testing connection... "
  if command -v ssh::test_connection >/dev/null 2>&1; then
    if ssh::test_connection "$host" "$user" "$port" "$key_file"; then
      printf "${COLOR_GREEN}OK${COLOR_RESET}\n"
    else
      printf "${COLOR_RED}FAILED${COLOR_RESET}\n"
      return 1
    fi
  else
    # Fallback basic test
    if ssh -q -o BatchMode=yes -o ConnectTimeout=5 "${user}@${host}" "echo ok" >/dev/null 2>&1; then
      printf "${COLOR_GREEN}OK${COLOR_RESET}\n"
    else
      printf "${COLOR_RED}FAILED${COLOR_RESET}\n"
      return 1
    fi
  fi

  # Build locally first
  printf "  Building locally... "
  if nself build >/dev/null 2>&1; then
    printf "${COLOR_GREEN}OK${COLOR_RESET}\n"
  else
    printf "${COLOR_RED}FAILED${COLOR_RESET}\n"
    log_error "Local build failed"
    return 1
  fi

  # Sync files
  printf "  Syncing files... "
  if command -v ssh::rsync_to >/dev/null 2>&1; then
    ssh::rsync_to "$host" "." "$deploy_path" "$user" "$port" "$key_file"
  else
    rsync -az --delete \
      --exclude '.git' \
      --exclude 'node_modules' \
      --exclude '.env.local' \
      -e "ssh -p $port" \
      ./ "${user}@${host}:${deploy_path}/"
  fi
  printf "${COLOR_GREEN}OK${COLOR_RESET}\n"

  # Copy secrets
  if [[ -f "$env_dir/.env.secrets" ]]; then
    printf "  Copying secrets... "
    scp -P "$port" "$env_dir/.env.secrets" "${user}@${host}:${deploy_path}/.env.secrets" 2>/dev/null
    printf "${COLOR_GREEN}OK${COLOR_RESET}\n"
  fi

  # Start services
  printf "  Starting services... "
  ssh -p "$port" "${user}@${host}" "cd '$deploy_path' && docker compose up -d" 2>/dev/null
  printf "${COLOR_GREEN}OK${COLOR_RESET}\n"

  # Verify health
  printf "  Verifying health... "
  if command -v health::wait_for_healthy >/dev/null 2>&1; then
    if health::wait_for_healthy "$host" "$deploy_path" 120 "$user" "$port" "$key_file"; then
      printf "${COLOR_GREEN}OK${COLOR_RESET}\n"
    else
      printf "${COLOR_YELLOW}PARTIAL${COLOR_RESET}\n"
    fi
  else
    sleep 5
    printf "${COLOR_GREEN}OK${COLOR_RESET}\n"
  fi

  printf "\n"
  log_success "Staging deployment complete"

  local domain
  domain=$(grep "^BASE_DOMAIN=" "$env_dir/.env" 2>/dev/null | cut -d'=' -f2)
  if [[ -n "$domain" ]]; then
    printf "\n  Staging URL: https://%s\n" "$domain"
  fi

  return 0
}

# Reset staging environment
staging_reset() {
  local include_data=""
  local force=""

  while [[ $# -gt 0 ]]; do
    case $1 in
      --data) include_data="true"; shift ;;
      --force|-f) force="true"; shift ;;
      *) shift ;;
    esac
  done

  show_command_header "nself staging reset" "Reset staging environment"

  local env_dir=".environments/staging"

  if [[ ! -d "$env_dir" ]]; then
    log_error "Staging environment not configured"
    return 1
  fi

  # Confirmation
  if [[ "$force" != "true" ]]; then
    printf "${COLOR_YELLOW}WARNING:${COLOR_RESET} This will reset the staging environment.\n"
    if [[ "$include_data" == "true" ]]; then
      printf "${COLOR_RED}ALL DATA WILL BE LOST!${COLOR_RESET}\n"
    fi
    printf "\n"
    printf "Are you sure? [y/N] "
    read -r response
    response=$(echo "$response" | tr '[:upper:]' '[:lower:]')
    if [[ "$response" != "y" && "$response" != "yes" ]]; then
      log_info "Reset cancelled"
      return 0
    fi
  fi

  # Get server details
  local host user port
  if [[ -f "$env_dir/server.json" ]]; then
    host=$(grep '"host"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    user=$(grep '"user"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    port=$(grep '"port"' "$env_dir/server.json" 2>/dev/null | grep -oE '[0-9]+' | head -1)
  fi

  if [[ -z "$host" ]]; then
    log_error "Staging server not configured"
    return 1
  fi

  user="${user:-root}"
  port="${port:-22}"
  local deploy_path="${STAGING_DEPLOY_PATH:-/opt/nself}"

  log_info "Resetting staging environment..."

  # Stop services
  printf "  Stopping services... "
  ssh -p "$port" "${user}@${host}" "cd '$deploy_path' && docker compose down" 2>/dev/null
  printf "${COLOR_GREEN}OK${COLOR_RESET}\n"

  # Remove data volumes if requested
  if [[ "$include_data" == "true" ]]; then
    printf "  Removing data volumes... "
    ssh -p "$port" "${user}@${host}" "cd '$deploy_path' && docker compose down -v" 2>/dev/null
    printf "${COLOR_GREEN}OK${COLOR_RESET}\n"
  fi

  # Restart services
  printf "  Restarting services... "
  ssh -p "$port" "${user}@${host}" "cd '$deploy_path' && docker compose up -d" 2>/dev/null
  printf "${COLOR_GREEN}OK${COLOR_RESET}\n"

  printf "\n"
  log_success "Staging environment reset complete"

  return 0
}

# Seed staging data
staging_seed() {
  local seed_file="${1:-}"
  local force=""

  while [[ $# -gt 0 ]]; do
    case $1 in
      --force|-f) force="true"; shift ;;
      --file) seed_file="$2"; shift 2 ;;
      *)
        if [[ -z "$seed_file" ]]; then
          seed_file="$1"
        fi
        shift
        ;;
    esac
  done

  show_command_header "nself staging seed" "Seed staging data"

  local env_dir=".environments/staging"

  # Check for seed file
  local seed_files="seeds/staging.sql seed/staging.sql data/seed-staging.sql"
  if [[ -z "$seed_file" ]]; then
    for sf in $seed_files; do
      if [[ -f "$sf" ]]; then
        seed_file="$sf"
        break
      fi
    done
  fi

  if [[ -z "$seed_file" ]] || [[ ! -f "$seed_file" ]]; then
    log_error "No seed file found"
    printf "\n"
    printf "Create a seed file at one of:\n"
    printf "  seeds/staging.sql\n"
    printf "  seed/staging.sql\n"
    printf "  data/seed-staging.sql\n"
    printf "\n"
    printf "Or specify a file: nself staging seed --file <path>\n"
    return 1
  fi

  log_info "Seeding from: $seed_file"

  # Get server details
  local host user port
  if [[ -f "$env_dir/server.json" ]]; then
    host=$(grep '"host"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    user=$(grep '"user"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    port=$(grep '"port"' "$env_dir/server.json" 2>/dev/null | grep -oE '[0-9]+' | head -1)
  fi

  if [[ -z "$host" ]]; then
    log_error "Staging server not configured"
    return 1
  fi

  user="${user:-root}"
  port="${port:-22}"
  local deploy_path="${STAGING_DEPLOY_PATH:-/opt/nself}"

  # Get database details
  local db_name db_user
  db_name=$(grep "^POSTGRES_DB=" "$env_dir/.env" 2>/dev/null | cut -d'=' -f2)
  db_user=$(grep "^POSTGRES_USER=" "$env_dir/.env" 2>/dev/null | cut -d'=' -f2)
  db_name="${db_name:-myproject_staging}"
  db_user="${db_user:-postgres}"

  # Copy and execute seed file
  printf "  Copying seed file... "
  scp -P "$port" "$seed_file" "${user}@${host}:/tmp/staging-seed.sql" 2>/dev/null
  printf "${COLOR_GREEN}OK${COLOR_RESET}\n"

  printf "  Executing seed... "
  ssh -p "$port" "${user}@${host}" "cd '$deploy_path' && docker compose exec -T postgres psql -U '$db_user' -d '$db_name' -f /dev/stdin < /tmp/staging-seed.sql" 2>/dev/null
  printf "${COLOR_GREEN}OK${COLOR_RESET}\n"

  # Cleanup
  ssh -p "$port" "${user}@${host}" "rm -f /tmp/staging-seed.sql" 2>/dev/null

  printf "\n"
  log_success "Staging data seeded"

  return 0
}

# Sync from production to staging
staging_sync() {
  local what="${1:-all}"
  local force=""

  while [[ $# -gt 0 ]]; do
    case $1 in
      --force|-f) force="true"; shift ;;
      db|data|database) what="database"; shift ;;
      files|storage) what="storage"; shift ;;
      *) shift ;;
    esac
  done

  show_command_header "nself staging sync" "Sync from production to staging"

  log_warning "Syncing from production to staging"
  printf "\n"

  # Confirmation
  if [[ "$force" != "true" ]]; then
    printf "${COLOR_YELLOW}WARNING:${COLOR_RESET} This will overwrite staging data with production data.\n"
    printf "\n"
    printf "Are you sure? [y/N] "
    read -r response
    response=$(echo "$response" | tr '[:upper:]' '[:lower:]')
    if [[ "$response" != "y" && "$response" != "yes" ]]; then
      log_info "Sync cancelled"
      return 0
    fi
  fi

  # Check if both environments exist
  if [[ ! -d ".environments/staging" ]]; then
    log_error "Staging environment not configured"
    return 1
  fi

  if [[ ! -d ".environments/prod" ]] && [[ ! -d ".environments/production" ]]; then
    log_error "Production environment not configured"
    return 1
  fi

  log_info "Syncing $what from production to staging..."
  printf "\n"
  printf "${COLOR_YELLOW}Note:${COLOR_RESET} This is a placeholder. Implement based on your infrastructure.\n"
  printf "\n"
  printf "Typical sync steps:\n"
  printf "  1. Create production database backup\n"
  printf "  2. Transfer backup to staging\n"
  printf "  3. Restore on staging (optionally anonymizing sensitive data)\n"
  printf "  4. Sync storage files if needed\n"
  printf "\n"
  printf "Consider creating a sync script at: scripts/sync-prod-to-staging.sh\n"

  return 0
}

# View staging logs
staging_logs() {
  local service="${1:-}"
  local follow=""
  local lines="100"

  while [[ $# -gt 0 ]]; do
    case $1 in
      -f|--follow) follow="-f"; shift ;;
      -n|--lines) lines="$2"; shift 2 ;;
      *)
        if [[ -z "$service" ]]; then
          service="$1"
        fi
        shift
        ;;
    esac
  done

  show_command_header "nself staging logs" "View staging logs"

  local env_dir=".environments/staging"

  # Get server details
  local host user port
  if [[ -f "$env_dir/server.json" ]]; then
    host=$(grep '"host"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    user=$(grep '"user"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    port=$(grep '"port"' "$env_dir/server.json" 2>/dev/null | grep -oE '[0-9]+' | head -1)
  fi

  if [[ -z "$host" ]]; then
    log_error "Staging server not configured"
    return 1
  fi

  user="${user:-root}"
  port="${port:-22}"
  local deploy_path="${STAGING_DEPLOY_PATH:-/opt/nself}"

  local logs_cmd="docker compose logs --tail=$lines $follow"
  if [[ -n "$service" ]]; then
    logs_cmd="$logs_cmd $service"
  fi

  ssh -t -p "$port" "${user}@${host}" "cd '$deploy_path' && $logs_cmd"
}

# SSH into staging server
staging_shell() {
  local service="${1:-}"

  show_command_header "nself staging shell" "SSH into staging"

  local env_dir=".environments/staging"

  # Get server details
  local host user port key_file
  if [[ -f "$env_dir/server.json" ]]; then
    host=$(grep '"host"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    user=$(grep '"user"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
    port=$(grep '"port"' "$env_dir/server.json" 2>/dev/null | grep -oE '[0-9]+' | head -1)
    key_file=$(grep '"key"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)
  fi

  if [[ -z "$host" ]]; then
    log_error "Staging server not configured"
    return 1
  fi

  user="${user:-root}"
  port="${port:-22}"
  local deploy_path="${STAGING_DEPLOY_PATH:-/opt/nself}"

  if [[ -n "$service" ]]; then
    # Shell into specific service container
    log_info "Connecting to $service container on $host..."
    ssh -t -p "$port" "${user}@${host}" "cd '$deploy_path' && docker compose exec $service sh"
  else
    # Shell into server
    log_info "Connecting to $host..."
    local ssh_cmd="ssh -t -p $port"
    if [[ -n "$key_file" ]]; then
      ssh_cmd="$ssh_cmd -i $key_file"
    fi
    $ssh_cmd "${user}@${host}"
  fi
}

# Generate staging secrets
staging_secrets() {
  local action="${1:-generate}"
  local force=""

  [[ "$2" == "--force" || "$2" == "-f" ]] && force="true"

  show_command_header "nself staging secrets" "Staging secrets management"

  local env_dir=".environments/staging"
  local secrets_file="$env_dir/.env.secrets"

  case "$action" in
    generate)
      if [[ -f "$secrets_file" ]] && [[ "$force" != "true" ]]; then
        log_error "Secrets file already exists. Use --force to overwrite."
        return 1
      fi

      log_info "Generating staging secrets..."

      cat > "$secrets_file" <<EOF
# Staging Secrets - DO NOT COMMIT TO VERSION CONTROL
# Generated by nself staging secrets on $(date +%Y-%m-%d)

# Database
POSTGRES_PASSWORD=$(openssl rand -hex 16)

# Security Secrets
HASURA_GRAPHQL_ADMIN_SECRET=$(openssl rand -hex 32)
JWT_SECRET=$(openssl rand -hex 32)
COOKIE_SECRET=$(openssl rand -hex 16)

# Service Credentials
MINIO_ROOT_PASSWORD=$(openssl rand -hex 16)
REDIS_PASSWORD=$(openssl rand -hex 16)
GRAFANA_ADMIN_PASSWORD=$(openssl rand -base64 12 | tr -dc 'a-zA-Z0-9')
EOF

      chmod 600 "$secrets_file"
      log_success "Generated secrets in $secrets_file"
      ;;

    show)
      if [[ ! -f "$secrets_file" ]]; then
        log_error "No secrets file found"
        return 1
      fi
      printf "Secrets in: %s\n\n" "$secrets_file"
      while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
          local key="${BASH_REMATCH[1]}"
          local value="${BASH_REMATCH[2]}"
          local masked="${value:0:4}****"
          printf "  %s=%s\n" "$key" "$masked"
        fi
      done < "$secrets_file"
      ;;

    *)
      printf "Usage: nself staging secrets <action>\n\n"
      printf "Actions:\n"
      printf "  generate [--force]   Generate staging secrets\n"
      printf "  show                 Show secrets (masked)\n"
      ;;
  esac
}

# Show help
show_staging_help() {
  printf "Usage: nself staging <subcommand> [options]\n"
  printf "\n"
  printf "Staging environment management\n"
  printf "\n"
  printf "Subcommands:\n"
  printf "  status               Show staging status (default)\n"
  printf "  init <domain>        Initialize staging environment\n"
  printf "  deploy               Deploy to staging server\n"
  printf "  reset [--data]       Reset staging environment\n"
  printf "  seed [file]          Seed staging with test data\n"
  printf "  sync [db|files]      Sync from production to staging\n"
  printf "  logs [service]       View staging logs\n"
  printf "  shell [service]      SSH into staging server\n"
  printf "  secrets              Manage staging secrets\n"
  printf "\n"
  printf "Examples:\n"
  printf "  nself staging init staging.example.com\n"
  printf "  nself staging deploy\n"
  printf "  nself staging reset --data\n"
  printf "  nself staging logs nginx -f\n"
  printf "  nself staging shell postgres\n"
  printf "\n"
  printf "Options:\n"
  printf "  --dry-run            Show what would be done without doing it\n"
  printf "  --force, -f          Skip confirmations\n"
}

# Export for use as library
export -f cmd_staging

# Execute if run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  cmd_staging "$@"
fi
