#!/usr/bin/env bash
# helm.sh - Helm chart management command
# Part of nself v0.4.7 - Infrastructure Everywhere
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source shared utilities (same pattern as other CLI commands)
source "${SCRIPT_DIR}/../lib/utils/display.sh" 2>/dev/null || true
source "${SCRIPT_DIR}/../lib/utils/env.sh" 2>/dev/null || true

# Fallback logging if display.sh failed to load
if ! declare -f log_success >/dev/null 2>&1; then
  log_success() { printf "\033[0;32m✓\033[0m %s\n" "$1"; }
fi
if ! declare -f log_warning >/dev/null 2>&1; then
  log_warning() { printf "\033[0;33m!\033[0m %s\n" "$1"; }
fi
if ! declare -f log_error >/dev/null 2>&1; then
  log_error() { printf "\033[0;31m✗\033[0m %s\n" "$1" >&2; }
fi
if ! declare -f log_info >/dev/null 2>&1; then
  log_info() { printf "\033[0;34mℹ\033[0m %s\n" "$1"; }
fi

show_helm_help() {
  cat << 'EOF'
nself helm - Helm Chart Management

USAGE:
  nself helm <subcommand> [options]

SUBCOMMANDS:
  init              Initialize Helm configuration for project
  generate          Generate Helm chart from nself project
  install           Install chart to Kubernetes cluster
  upgrade           Upgrade existing Helm release
  rollback          Rollback to previous release version
  uninstall         Uninstall a Helm release
  list              List Helm releases
  status            Show status of a release
  values            Show/edit values for a release
  template          Render chart templates locally

  repo              Helm repository management
    add             Add a chart repository
    remove          Remove a repository
    update          Update repository index
    list            List configured repositories

  package           Package chart for distribution
  push              Push chart to repository

EXAMPLES:
  nself helm init                        # Initialize Helm config
  nself helm generate                    # Generate Helm chart
  nself helm install myapp               # Install chart as 'myapp'
  nself helm upgrade myapp               # Upgrade release
  nself helm rollback myapp              # Rollback release
  nself helm status myapp                # Check status
  nself helm list                        # List all releases

  nself helm repo add bitnami https://charts.bitnami.com/bitnami
  nself helm template > rendered.yaml    # Preview templates

OPTIONS:
  -n, --namespace   Kubernetes namespace
  -f, --values      Values file to use
  --set             Set individual values (key=value)
  --version         Chart version for install/upgrade
  --dry-run         Simulate without making changes
  -h, --help        Show this help message

PREREQUISITES:
  - helm CLI installed (v3+)
  - kubectl configured with cluster access
  - nself project with docker-compose.yml

See 'nself helm <subcommand> --help' for subcommand-specific options.
EOF
}

# Check helm availability
check_helm() {
  if ! command -v helm &>/dev/null; then
    log_error "helm not found. Please install Helm first."
    log_info "Installation: https://helm.sh/docs/intro/install/"
    return 1
  fi

  # Check helm version (require v3+)
  local version
  version=$(helm version --short 2>/dev/null | grep -oE 'v[0-9]+' | head -1 | tr -d 'v')

  if [[ -n "$version" ]] && [[ "$version" -lt 3 ]]; then
    log_error "Helm v3+ required. Found: v$version"
    return 1
  fi

  return 0
}

# Get release namespace
get_namespace() {
  echo "${HELM_NAMESPACE:-${NSELF_K8S_NAMESPACE:-default}}"
}

# Get chart directory
get_chart_dir() {
  echo "${CHART_DIR:-.nself/helm}"
}

# === INIT SUBCOMMAND ===
cmd_helm_init() {
  local project_name="${PROJECT_NAME:-$(basename "$(pwd)")}"

  log_info "Initializing Helm configuration..."

  check_helm || return 1

  # Create Helm directory structure
  local chart_dir
  chart_dir=$(get_chart_dir)

  mkdir -p "$chart_dir"

  # Create basic Chart.yaml
  cat > "$chart_dir/Chart.yaml" << EOF
apiVersion: v2
name: ${project_name}
description: Helm chart for ${project_name} generated by nself
type: application
version: 0.1.0
appVersion: "1.0.0"
maintainers:
  - name: nself
    url: https://github.com/acamarata/nself
keywords:
  - nself
  - docker-compose
  - kubernetes
EOF

  # Create values.yaml
  cat > "$chart_dir/values.yaml" << EOF
# Default values for ${project_name}
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Global settings
global:
  environment: production
  namespace: ${project_name}

# Image settings
image:
  registry: ""
  pullPolicy: IfNotPresent
  pullSecrets: []

# Replicas
replicaCount: 2

# Resource defaults
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi

# Service settings
service:
  type: ClusterIP
  port: 80

# Ingress settings
ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: ${project_name}.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: ${project_name}-tls
      hosts:
        - ${project_name}.example.com

# PostgreSQL (if using subchart)
postgresql:
  enabled: true
  auth:
    postgresPassword: ""
    database: ${project_name}
  primary:
    persistence:
      size: 10Gi

# Redis (if using subchart)
redis:
  enabled: false
  auth:
    enabled: false

# MinIO (if using subchart)
minio:
  enabled: false
  mode: standalone
  persistence:
    size: 50Gi

# Monitoring
monitoring:
  enabled: false
  serviceMonitor:
    enabled: true

# Autoscaling
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80

# Pod disruption budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}
EOF

  # Create templates directory
  mkdir -p "$chart_dir/templates"

  # Create NOTES.txt
  cat > "$chart_dir/templates/NOTES.txt" << 'EOF'
Thank you for installing {{ .Chart.Name }}.

Your release is named {{ .Release.Name }}.

To get the application URL:
{{- if .Values.ingress.enabled }}
{{- range $host := .Values.ingress.hosts }}
  http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}
{{- end }}
{{- else }}
  kubectl port-forward svc/{{ include "chart.fullname" . }} 8080:{{ .Values.service.port }}
{{- end }}

For more information, visit:
  https://github.com/acamarata/nself
EOF

  # Create _helpers.tpl
  cat > "$chart_dir/templates/_helpers.tpl" << 'EOF'
{{/*
Expand the name of the chart.
*/}}
{{- define "chart.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
*/}}
{{- define "chart.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "chart.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "chart.labels" -}}
helm.sh/chart: {{ include "chart.chart" . }}
{{ include "chart.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "chart.selectorLabels" -}}
app.kubernetes.io/name: {{ include "chart.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "chart.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "chart.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}
EOF

  log_success "Helm configuration initialized"
  log_info "Chart directory: $chart_dir"
  log_info "Next: Run 'nself helm generate' to create templates from docker-compose.yml"
}

# === GENERATE SUBCOMMAND ===
cmd_helm_generate() {
  local compose_file="${1:-docker-compose.yml}"
  local chart_dir
  chart_dir=$(get_chart_dir)

  if [[ ! -f "$compose_file" ]]; then
    log_error "Docker Compose file not found: $compose_file"
    log_info "Run 'nself build' first to generate docker-compose.yml"
    return 1
  fi

  if [[ ! -f "$chart_dir/Chart.yaml" ]]; then
    log_warning "Helm not initialized. Running init first..."
    cmd_helm_init
  fi

  log_info "Generating Helm templates from Docker Compose..."

  # Create templates directory
  mkdir -p "$chart_dir/templates"

  # Parse services and generate templates
  local services
  services=$(grep -E "^[[:space:]]{2}[a-zA-Z0-9_-]+:$" "$compose_file" | tr -d ' :' || echo "")

  for service in $services; do
    [[ -z "$service" ]] && continue
    [[ "$service" == "version" || "$service" == "services" || "$service" == "volumes" || "$service" == "networks" ]] && continue

    printf "  Generating templates for: %s\n" "$service"

    # Generate deployment template
    _generate_helm_deployment "$service" > "$chart_dir/templates/${service}-deployment.yaml"

    # Generate service template
    _generate_helm_service "$service" > "$chart_dir/templates/${service}-service.yaml"
  done

  # Generate ingress template
  _generate_helm_ingress > "$chart_dir/templates/ingress.yaml"

  # Generate configmap template
  _generate_helm_configmap > "$chart_dir/templates/configmap.yaml"

  # Generate secrets template
  _generate_helm_secrets > "$chart_dir/templates/secrets.yaml"

  log_success "Helm templates generated"
  log_info "Templates in: $chart_dir/templates/"
  log_info "Next: Review values.yaml and run 'nself helm install <release-name>'"
}

# Generate Helm deployment template
_generate_helm_deployment() {
  local service="$1"

  cat << 'EOF'
{{- $serviceName := "SERVICE_NAME" }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "chart.fullname" . }}-SERVICE_NAME
  labels:
    {{- include "chart.labels" . | nindent 4 }}
    app.kubernetes.io/component: SERVICE_NAME
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "chart.selectorLabels" . | nindent 6 }}
      app.kubernetes.io/component: SERVICE_NAME
  template:
    metadata:
      labels:
        {{- include "chart.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: SERVICE_NAME
    spec:
      {{- with .Values.image.pullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      containers:
        - name: SERVICE_NAME
          image: "{{ .Values.image.registry }}SERVICE_NAME:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
          envFrom:
            - configMapRef:
                name: {{ include "chart.fullname" . }}-config
            - secretRef:
                name: {{ include "chart.fullname" . }}-secrets
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
EOF
  # Replace SERVICE_NAME with actual service name
  sed "s/SERVICE_NAME/$service/g"
}

# Generate Helm service template
_generate_helm_service() {
  local service="$1"

  cat << 'EOF'
apiVersion: v1
kind: Service
metadata:
  name: {{ include "chart.fullname" . }}-SERVICE_NAME
  labels:
    {{- include "chart.labels" . | nindent 4 }}
    app.kubernetes.io/component: SERVICE_NAME
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: http
      protocol: TCP
      name: http
  selector:
    {{- include "chart.selectorLabels" . | nindent 4 }}
    app.kubernetes.io/component: SERVICE_NAME
EOF
  sed "s/SERVICE_NAME/$service/g"
}

# Generate Helm ingress template
_generate_helm_ingress() {
  cat << 'EOF'
{{- if .Values.ingress.enabled -}}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "chart.fullname" . }}
  labels:
    {{- include "chart.labels" . | nindent 4 }}
  {{- with .Values.ingress.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  {{- if .Values.ingress.className }}
  ingressClassName: {{ .Values.ingress.className }}
  {{- end }}
  {{- if .Values.ingress.tls }}
  tls:
    {{- range .Values.ingress.tls }}
    - hosts:
        {{- range .hosts }}
        - {{ . | quote }}
        {{- end }}
      secretName: {{ .secretName }}
    {{- end }}
  {{- end }}
  rules:
    {{- range .Values.ingress.hosts }}
    - host: {{ .host | quote }}
      http:
        paths:
          {{- range .paths }}
          - path: {{ .path }}
            pathType: {{ .pathType }}
            backend:
              service:
                name: {{ include "chart.fullname" $ }}
                port:
                  number: {{ $.Values.service.port }}
          {{- end }}
    {{- end }}
{{- end }}
EOF
}

# Generate Helm configmap template
_generate_helm_configmap() {
  cat << 'EOF'
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "chart.fullname" . }}-config
  labels:
    {{- include "chart.labels" . | nindent 4 }}
data:
  ENVIRONMENT: {{ .Values.global.environment | quote }}
  {{- range $key, $value := .Values.config }}
  {{ $key }}: {{ $value | quote }}
  {{- end }}
EOF
}

# Generate Helm secrets template
_generate_helm_secrets() {
  cat << 'EOF'
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "chart.fullname" . }}-secrets
  labels:
    {{- include "chart.labels" . | nindent 4 }}
type: Opaque
data:
  {{- range $key, $value := .Values.secrets }}
  {{ $key }}: {{ $value | b64enc | quote }}
  {{- end }}
EOF
}

# === INSTALL SUBCOMMAND ===
cmd_helm_install() {
  local release_name="${1:-}"
  local chart_dir
  chart_dir=$(get_chart_dir)
  local namespace
  namespace=$(get_namespace)

  check_helm || return 1

  if [[ -z "$release_name" ]]; then
    release_name="${PROJECT_NAME:-$(basename "$(pwd)")}"
  fi

  if [[ ! -f "$chart_dir/Chart.yaml" ]]; then
    log_error "Helm chart not found. Run 'nself helm init' first."
    return 1
  fi

  log_info "Installing Helm release: $release_name"

  local helm_args=()
  helm_args+=("install" "$release_name" "$chart_dir")
  helm_args+=("--namespace" "$namespace")
  helm_args+=("--create-namespace")

  # Add values file if specified
  if [[ -n "${VALUES_FILE:-}" ]]; then
    helm_args+=("-f" "$VALUES_FILE")
  fi

  # Add individual set values
  if [[ -n "${SET_VALUES:-}" ]]; then
    IFS=',' read -ra values <<< "$SET_VALUES"
    for val in "${values[@]}"; do
      helm_args+=("--set" "$val")
    done
  fi

  # Dry run if specified
  if [[ "${DRY_RUN:-false}" == "true" ]]; then
    helm_args+=("--dry-run")
    log_info "Dry-run mode - no changes will be applied"
  fi

  # Wait for resources
  helm_args+=("--wait")
  helm_args+=("--timeout" "5m")

  if helm "${helm_args[@]}"; then
    log_success "Release $release_name installed successfully"
    helm status "$release_name" -n "$namespace"
  else
    log_error "Failed to install release"
    return 1
  fi
}

# === UPGRADE SUBCOMMAND ===
cmd_helm_upgrade() {
  local release_name="${1:-}"
  local chart_dir
  chart_dir=$(get_chart_dir)
  local namespace
  namespace=$(get_namespace)

  check_helm || return 1

  if [[ -z "$release_name" ]]; then
    log_error "Release name required"
    return 1
  fi

  log_info "Upgrading Helm release: $release_name"

  local helm_args=()
  helm_args+=("upgrade" "$release_name" "$chart_dir")
  helm_args+=("--namespace" "$namespace")

  if [[ -n "${VALUES_FILE:-}" ]]; then
    helm_args+=("-f" "$VALUES_FILE")
  fi

  if [[ -n "${SET_VALUES:-}" ]]; then
    IFS=',' read -ra values <<< "$SET_VALUES"
    for val in "${values[@]}"; do
      helm_args+=("--set" "$val")
    done
  fi

  if [[ "${DRY_RUN:-false}" == "true" ]]; then
    helm_args+=("--dry-run")
  fi

  helm_args+=("--wait")
  helm_args+=("--timeout" "5m")

  if helm "${helm_args[@]}"; then
    log_success "Release $release_name upgraded successfully"
    helm status "$release_name" -n "$namespace"
  else
    log_error "Failed to upgrade release"
    return 1
  fi
}

# === ROLLBACK SUBCOMMAND ===
cmd_helm_rollback() {
  local release_name="${1:-}"
  local revision="${2:-}"
  local namespace
  namespace=$(get_namespace)

  check_helm || return 1

  if [[ -z "$release_name" ]]; then
    log_error "Release name required"
    return 1
  fi

  log_info "Rolling back release: $release_name"

  # Show history first
  printf "\nRelease history:\n"
  helm history "$release_name" -n "$namespace"

  local helm_args=()
  helm_args+=("rollback" "$release_name")

  if [[ -n "$revision" ]]; then
    helm_args+=("$revision")
  fi

  helm_args+=("--namespace" "$namespace")
  helm_args+=("--wait")

  if helm "${helm_args[@]}"; then
    log_success "Release $release_name rolled back"
    helm status "$release_name" -n "$namespace"
  else
    log_error "Failed to rollback release"
    return 1
  fi
}

# === UNINSTALL SUBCOMMAND ===
cmd_helm_uninstall() {
  local release_name="${1:-}"
  local namespace
  namespace=$(get_namespace)

  check_helm || return 1

  if [[ -z "$release_name" ]]; then
    log_error "Release name required"
    return 1
  fi

  log_warning "This will uninstall release: $release_name"
  printf "Are you sure? [y/N]: "
  read -r confirm
  confirm=$(echo "$confirm" | tr '[:upper:]' '[:lower:]')

  if [[ "$confirm" != "y" && "$confirm" != "yes" ]]; then
    log_info "Aborted"
    return 0
  fi

  if helm uninstall "$release_name" -n "$namespace"; then
    log_success "Release $release_name uninstalled"
  else
    log_error "Failed to uninstall release"
    return 1
  fi
}

# === LIST SUBCOMMAND ===
cmd_helm_list() {
  local namespace
  namespace=$(get_namespace)

  check_helm || return 1

  if [[ "${ALL_NAMESPACES:-false}" == "true" ]]; then
    helm list --all-namespaces
  else
    helm list -n "$namespace"
  fi
}

# === STATUS SUBCOMMAND ===
cmd_helm_status() {
  local release_name="${1:-}"
  local namespace
  namespace=$(get_namespace)

  check_helm || return 1

  if [[ -z "$release_name" ]]; then
    log_error "Release name required"
    return 1
  fi

  helm status "$release_name" -n "$namespace"
}

# === VALUES SUBCOMMAND ===
cmd_helm_values() {
  local release_name="${1:-}"
  local namespace
  namespace=$(get_namespace)

  check_helm || return 1

  if [[ -z "$release_name" ]]; then
    # Show local values file
    local chart_dir
    chart_dir=$(get_chart_dir)

    if [[ -f "$chart_dir/values.yaml" ]]; then
      cat "$chart_dir/values.yaml"
    else
      log_error "No values.yaml found"
      return 1
    fi
  else
    # Show release values
    helm get values "$release_name" -n "$namespace" --all
  fi
}

# === TEMPLATE SUBCOMMAND ===
cmd_helm_template() {
  local chart_dir
  chart_dir=$(get_chart_dir)

  check_helm || return 1

  if [[ ! -f "$chart_dir/Chart.yaml" ]]; then
    log_error "Helm chart not found. Run 'nself helm init' first."
    return 1
  fi

  local helm_args=()
  helm_args+=("template" "preview" "$chart_dir")

  if [[ -n "${VALUES_FILE:-}" ]]; then
    helm_args+=("-f" "$VALUES_FILE")
  fi

  if [[ -n "${SET_VALUES:-}" ]]; then
    IFS=',' read -ra values <<< "$SET_VALUES"
    for val in "${values[@]}"; do
      helm_args+=("--set" "$val")
    done
  fi

  helm "${helm_args[@]}"
}

# === REPO SUBCOMMANDS ===
cmd_helm_repo() {
  local action="${1:-list}"
  shift || true

  check_helm || return 1

  case "$action" in
    add)
      local name="$1"
      local url="$2"
      if [[ -z "$name" || -z "$url" ]]; then
        log_error "Usage: nself helm repo add <name> <url>"
        return 1
      fi
      helm repo add "$name" "$url"
      helm repo update
      log_success "Repository $name added"
      ;;
    remove|rm)
      local name="$1"
      if [[ -z "$name" ]]; then
        log_error "Usage: nself helm repo remove <name>"
        return 1
      fi
      helm repo remove "$name"
      log_success "Repository $name removed"
      ;;
    update)
      helm repo update
      log_success "Repositories updated"
      ;;
    list)
      helm repo list
      ;;
    *)
      log_error "Unknown repo action: $action"
      log_info "Available: add, remove, update, list"
      return 1
      ;;
  esac
}

# === PACKAGE SUBCOMMAND ===
cmd_helm_package() {
  local chart_dir
  chart_dir=$(get_chart_dir)
  local output_dir="${1:-.}"

  check_helm || return 1

  if [[ ! -f "$chart_dir/Chart.yaml" ]]; then
    log_error "Helm chart not found"
    return 1
  fi

  log_info "Packaging Helm chart..."

  if helm package "$chart_dir" -d "$output_dir"; then
    log_success "Chart packaged successfully"
    ls -la "$output_dir"/*.tgz 2>/dev/null | tail -1
  else
    log_error "Failed to package chart"
    return 1
  fi
}

# === MAIN ENTRY POINT ===
main() {
  local subcommand="${1:-}"
  shift || true

  # Parse global options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n|--namespace)
        export HELM_NAMESPACE="$2"
        shift 2
        ;;
      -f|--values)
        export VALUES_FILE="$2"
        shift 2
        ;;
      --set)
        if [[ -n "${SET_VALUES:-}" ]]; then
          SET_VALUES="${SET_VALUES},$2"
        else
          SET_VALUES="$2"
        fi
        export SET_VALUES
        shift 2
        ;;
      --version)
        export CHART_VERSION="$2"
        shift 2
        ;;
      --dry-run)
        export DRY_RUN="true"
        shift
        ;;
      -A|--all-namespaces)
        export ALL_NAMESPACES="true"
        shift
        ;;
      -h|--help)
        show_helm_help
        return 0
        ;;
      *)
        break
        ;;
    esac
  done

  case "$subcommand" in
    ""|help|-h|--help)
      show_helm_help
      ;;
    init)
      cmd_helm_init "$@"
      ;;
    generate|gen)
      cmd_helm_generate "$@"
      ;;
    install)
      cmd_helm_install "$@"
      ;;
    upgrade)
      cmd_helm_upgrade "$@"
      ;;
    rollback)
      cmd_helm_rollback "$@"
      ;;
    uninstall|delete)
      cmd_helm_uninstall "$@"
      ;;
    list|ls)
      cmd_helm_list "$@"
      ;;
    status)
      cmd_helm_status "$@"
      ;;
    values)
      cmd_helm_values "$@"
      ;;
    template)
      cmd_helm_template "$@"
      ;;
    repo)
      cmd_helm_repo "$@"
      ;;
    package|pkg)
      cmd_helm_package "$@"
      ;;
    *)
      log_error "Unknown subcommand: $subcommand"
      show_helm_help
      return 1
      ;;
  esac
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
