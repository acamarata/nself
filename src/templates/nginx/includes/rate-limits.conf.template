# Rate Limiting Configuration
# Generated by nself - Configure via: nself auth rate-limit config
#
# Rate limiting zones protect against abuse and DDoS attacks
# Different zones apply different limits based on endpoint type

# ============================================================================
# Rate Limit Zones
# ============================================================================

# General zone - Default for all endpoints
# 10MB zone can store ~160k IP addresses
limit_req_zone $binary_remote_addr zone=general:10m rate={{RATE_LIMIT_GENERAL_RATE:-10r/s}};

# GraphQL API zone - Higher limits for API calls
# Burst handling allows temporary spikes while preventing sustained abuse
limit_req_zone $binary_remote_addr zone=graphql_api:10m rate={{RATE_LIMIT_GRAPHQL_RATE:-100r/m}};

# Auth endpoints zone - Strict limits to prevent brute force
# Lower rate to protect login, signup, password reset endpoints
limit_req_zone $binary_remote_addr zone=auth:10m rate={{RATE_LIMIT_AUTH_RATE:-10r/m}};

# Upload zone - Very restrictive for file uploads
# Prevents storage exhaustion and abuse
limit_req_zone $binary_remote_addr zone=uploads:10m rate={{RATE_LIMIT_UPLOAD_RATE:-5r/m}};

# Static assets zone - High limits for CSS/JS/images
# These are typically cached and need higher throughput
limit_req_zone $binary_remote_addr zone=static:10m rate={{RATE_LIMIT_STATIC_RATE:-1000r/m}};

# Webhook zone - Moderate limits for incoming webhooks
limit_req_zone $binary_remote_addr zone=webhooks:10m rate={{RATE_LIMIT_WEBHOOK_RATE:-30r/m}};

# Functions zone - Per-function rate limiting
limit_req_zone $binary_remote_addr zone=functions:10m rate={{RATE_LIMIT_FUNCTIONS_RATE:-50r/m}};

# User-based rate limiting (requires authentication header)
# Uses JWT token or user ID instead of IP address
limit_req_zone $http_authorization zone=user_api:10m rate={{RATE_LIMIT_USER_RATE:-1000r/m}};

# ============================================================================
# Connection Limits (DDoS Protection Layer 1)
# ============================================================================

# Limit concurrent connections per IP address
# Prevents connection exhaustion attacks
limit_conn_zone $binary_remote_addr zone=conn_limit_per_ip:10m;

# Limit total server connections
# Protects server resources under extreme load
limit_conn_zone $server_name zone=conn_limit_server:10m;

# ============================================================================
# Request Size Limits (DDoS Protection Layer 2)
# ============================================================================

# Default body size limit (overridden per location as needed)
# Prevents memory exhaustion from huge payloads
client_max_body_size {{CLIENT_MAX_BODY_SIZE:-10M}};

# Buffer size for request headers
# Protects against slowloris attacks with huge headers
client_header_buffer_size {{CLIENT_HEADER_BUFFER_SIZE:-1k}};
large_client_header_buffers 4 {{LARGE_CLIENT_HEADER_BUFFERS:-8k}};

# Body buffer size
client_body_buffer_size {{CLIENT_BODY_BUFFER_SIZE:-16k}};

# ============================================================================
# Timeout Protection (DDoS Protection Layer 3 - Slow Request Protection)
# ============================================================================

# Client timeouts prevent slowloris and slow POST attacks
# Timeout for reading client request body
client_body_timeout {{CLIENT_BODY_TIMEOUT:-12s}};

# Timeout for reading client request headers
client_header_timeout {{CLIENT_HEADER_TIMEOUT:-12s}};

# Timeout for keep-alive connections
keepalive_timeout {{KEEPALIVE_TIMEOUT:-15s}};

# Timeout for transmitting response to client
send_timeout {{SEND_TIMEOUT:-10s}};

# ============================================================================
# Rate Limit Status Codes
# ============================================================================

# Return 429 Too Many Requests when rate limited
limit_req_status 429;
limit_conn_status 429;

# ============================================================================
# Geographic Blocking (Optional - Uncomment to enable)
# ============================================================================

# GeoIP-based blocking requires ngx_http_geoip2_module
# Uncomment and configure to block/allow specific countries

# Example: Block specific countries
# map $geoip2_data_country_code $blocked_country {
#     default 0;
#     CN 1;  # China
#     RU 1;  # Russia
#     KP 1;  # North Korea
# }

# ============================================================================
# IP Whitelist/Blacklist (Managed via nself auth rate-limit)
# ============================================================================

# Whitelist map - Bypass rate limits for trusted IPs
# Populated from database via: nself auth rate-limit whitelist add <ip>
geo $rate_limit_whitelist {
    default 0;
    {{RATE_LIMIT_WHITELIST}}
}

# Blacklist map - Block malicious IPs entirely
# Populated from database via: nself auth rate-limit block add <ip>
geo $rate_limit_blacklist {
    default 0;
    {{RATE_LIMIT_BLACKLIST}}
}

# ============================================================================
# Rate Limit Bypass for Whitelisted IPs
# ============================================================================

# If IP is whitelisted, set rate limit key to empty string (bypasses limits)
map $rate_limit_whitelist $limit_key {
    0 $binary_remote_addr;
    1 "";
}

# ============================================================================
# DDoS Protection Headers
# ============================================================================

# Add rate limit info to responses (helps clients implement backoff)
# Note: These are added in location blocks, not globally

# Example headers (added per location):
# add_header X-RateLimit-Limit $limit_req_zone_limit always;
# add_header X-RateLimit-Remaining $limit_req_zone_remaining always;
# add_header X-RateLimit-Reset $limit_req_zone_reset always;

# ============================================================================
# Usage in Location Blocks
# ============================================================================

# Apply rate limits in your nginx site configs like this:
#
# GraphQL API:
#   limit_req zone=graphql_api burst=20 nodelay;
#   limit_conn conn_limit_per_ip 10;
#
# Auth endpoints:
#   limit_req zone=auth burst=5 nodelay;
#   limit_conn conn_limit_per_ip 5;
#
# File uploads:
#   limit_req zone=uploads burst=2 nodelay;
#   client_max_body_size 100M;
#
# Static assets:
#   limit_req zone=static burst=50 nodelay;
#
# Webhooks:
#   limit_req zone=webhooks burst=10 nodelay;

# ============================================================================
# Monitoring & Logging
# ============================================================================

# Log rate limit rejections for analysis
# These go to error.log with 'limit_req' identifier
# Parse with: grep "limit_req" /var/log/nginx/error.log

# For Prometheus/Grafana integration:
# Use nginx-prometheus-exporter to expose rate limit metrics

# ============================================================================
# Configuration Variables Reference
# ============================================================================

# Set these in your .env file to customize rate limits:
#
# RATE_LIMIT_GENERAL_RATE=10r/s          # General API rate (requests per second)
# RATE_LIMIT_GRAPHQL_RATE=100r/m         # GraphQL rate (requests per minute)
# RATE_LIMIT_AUTH_RATE=10r/m             # Auth endpoints rate
# RATE_LIMIT_UPLOAD_RATE=5r/m            # Upload endpoints rate
# RATE_LIMIT_STATIC_RATE=1000r/m         # Static assets rate
# RATE_LIMIT_WEBHOOK_RATE=30r/m          # Webhook rate
# RATE_LIMIT_FUNCTIONS_RATE=50r/m        # Functions rate
# RATE_LIMIT_USER_RATE=1000r/m           # Per-user rate (authenticated)
#
# CLIENT_MAX_BODY_SIZE=10M               # Max request body size
# CLIENT_HEADER_BUFFER_SIZE=1k           # Header buffer size
# LARGE_CLIENT_HEADER_BUFFERS=8k         # Large header buffer size
# CLIENT_BODY_BUFFER_SIZE=16k            # Body buffer size
# CLIENT_BODY_TIMEOUT=12s                # Body read timeout
# CLIENT_HEADER_TIMEOUT=12s              # Header read timeout
# KEEPALIVE_TIMEOUT=15s                  # Keep-alive timeout
# SEND_TIMEOUT=10s                       # Send timeout
