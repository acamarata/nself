import { Worker, Job, Queue } from 'bullmq';
import { createBullBoard } from '@bull-board/api';
import { BullMQAdapter } from '@bull-board/api/bullMQAdapter';
import { ExpressAdapter } from '@bull-board/express';
import express from 'express';
import axios from 'axios';

// Redis connection
const redisConfig = {
  host: process.env.REDIS_HOST || 'redis',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD || undefined,
};

// Queue for currency processing
const currencyQueue = new Queue('currency-processing', { connection: redisConfig });

// Currency processing worker
const currencyWorker = new Worker(
  'currency-processing',
  async (job: Job) => {
    console.log(`Processing currency job:`, job.id);
    
    const { data } = job;
    
    try {
      switch (job.name) {
        case 'fetch-exchange-rates':
          return await fetchExchangeRates(data);
        case 'fetch-crypto-prices':
          return await fetchCryptoPrices(data);
        case 'fetch-metal-prices':
          return await fetchMetalPrices(data);
        case 'calculate-rate-changes':
          return await calculateRateChanges(data);
        case 'cleanup-old-rates':
          return await cleanupOldRates(data);
        default:
          throw new Error(`Unknown job type: ${job.name}`);
      }
    } catch (error) {
      console.error(`Failed currency job:`, job.id, error);
      throw error;
    }
  },
  { 
    connection: redisConfig,
    concurrency: 2 // Process up to 2 jobs simultaneously
  }
);

// Exchange rate fetching (using free API or simulated data)
async function fetchExchangeRates(data: { baseCurrency: string, targetCurrencies: string[] }) {
  console.log(`Fetching exchange rates for ${data.baseCurrency} -> ${data.targetCurrencies.join(', ')}`);
  
  const results = [];
  
  // In a real implementation, you'd use a free API like:
  // - exchangerate-api.com (free tier available)
  // - currencyapi.com (free tier)
  // - fixer.io (free tier)
  
  for (const targetCurrency of data.targetCurrencies) {
    try {
      // Simulate exchange rate data (replace with real API call)
      const rate = generateSimulatedRate(data.baseCurrency, targetCurrency);
      const rateData = {
        base_currency: data.baseCurrency,
        target_currency: targetCurrency,
        rate: rate,
        timestamp: new Date(),
        source: 'simulated', // Would be actual API source
      };
      
      // Store in PostgreSQL via Hasura
      await storeExchangeRate(rateData);
      
      // Cache current rate in Redis
      await cacheCurrentRate(rateData);
      
      results.push({ success: true, pair: `${data.baseCurrency}/${targetCurrency}`, rate });
    } catch (error) {
      console.error(`Failed to fetch rate for ${data.baseCurrency}/${targetCurrency}:`, error);
      results.push({ 
        success: false, 
        pair: `${data.baseCurrency}/${targetCurrency}`, 
        error: error.message 
      });
    }
    
    // Rate limiting delay
    await new Promise(resolve => setTimeout(resolve, 200));
  }
  
  return { processedPairs: results.length, results };
}

async function fetchCryptoPrices(data: { cryptos: string[], vsCurrency: string }) {
  console.log(`Fetching crypto prices for ${data.cryptos.join(', ')} vs ${data.vsCurrency}`);
  
  const results = [];
  
  // For demo purposes, simulate crypto price data
  // In real implementation, use free APIs like:
  // - CoinGecko API (free tier)
  // - CoinCap API (free)
  // - CryptoCompare API (free tier)
  
  for (const crypto of data.cryptos) {
    try {
      const price = generateSimulatedCryptoPrice(crypto);
      const priceData = {
        symbol: crypto.toUpperCase(),
        vs_currency: data.vsCurrency.toUpperCase(),
        price: price,
        market_cap: price * Math.random() * 1000000000, // Simulated market cap
        volume_24h: price * Math.random() * 100000000, // Simulated volume
        change_24h: (Math.random() - 0.5) * 20, // -10% to +10% change
        timestamp: new Date(),
        source: 'simulated',
      };
      
      // Store in PostgreSQL
      await storeCryptoPrice(priceData);
      
      // Cache in Redis
      await cacheCurrentCryptoPrice(priceData);
      
      results.push({ success: true, crypto, price });
    } catch (error) {
      console.error(`Failed to fetch price for ${crypto}:`, error);
      results.push({ success: false, crypto, error: error.message });
    }
    
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  return { processedCryptos: results.length, results };
}

async function fetchMetalPrices(data: { metals: string[] }) {
  console.log(`Fetching metal prices for ${data.metals.join(', ')}`);
  
  const results = [];
  
  // Simulate metal price data
  // In real implementation, use APIs like:
  // - MetalsAPI (free tier)
  // - Metals-API.com
  // - Alpha Vantage commodities
  
  for (const metal of data.metals) {
    try {
      const price = generateSimulatedMetalPrice(metal);
      const priceData = {
        metal: metal.toUpperCase(),
        price_per_oz: price,
        currency: 'USD',
        change_24h: (Math.random() - 0.5) * 10, // -5% to +5% change
        timestamp: new Date(),
        source: 'simulated',
      };
      
      // Store in PostgreSQL
      await storeMetalPrice(priceData);
      
      // Cache in Redis
      await cacheCurrentMetalPrice(priceData);
      
      results.push({ success: true, metal, price });
    } catch (error) {
      console.error(`Failed to fetch price for ${metal}:`, error);
      results.push({ success: false, metal, error: error.message });
    }
    
    await new Promise(resolve => setTimeout(resolve, 150));
  }
  
  return { processedMetals: results.length, results };
}

async function calculateRateChanges(data: { timeframe: string }) {
  console.log(`Calculating rate changes for timeframe: ${data.timeframe}`);
  
  const timeframes = {
    '1h': 1,
    '24h': 24,
    '7d': 24 * 7,
    '30d': 24 * 30,
  };
  
  const hoursBack = timeframes[data.timeframe as keyof typeof timeframes] || 24;
  const since = new Date();
  since.setHours(since.getHours() - hoursBack);
  
  try {
    // Get current rates
    const currentRatesQuery = `
      query GetCurrentRates {
        exchange_rates(
          order_by: { created_at: desc }
          distinct_on: [base_currency, target_currency]
        ) {
          base_currency
          target_currency
          rate
          created_at
        }
      }
    `;
    
    // Get historical rates
    const historicalRatesQuery = `
      query GetHistoricalRates($since: timestamptz!) {
        exchange_rates(
          where: { created_at: { _lte: $since } }
          order_by: { created_at: desc }
          distinct_on: [base_currency, target_currency]
        ) {
          base_currency
          target_currency
          rate
          created_at
        }
      }
    `;
    
    const [currentResponse, historicalResponse] = await Promise.all([
      axios.post(
        process.env.HASURA_ENDPOINT || 'http://hasura:8080/v1/graphql',
        { query: currentRatesQuery },
        {
          headers: {
            'Content-Type': 'application/json',
            'X-Hasura-Admin-Secret': process.env.HASURA_ADMIN_SECRET,
          },
        }
      ),
      axios.post(
        process.env.HASURA_ENDPOINT || 'http://hasura:8080/v1/graphql',
        { query: historicalRatesQuery, variables: { since: since.toISOString() } },
        {
          headers: {
            'Content-Type': 'application/json',
            'X-Hasura-Admin-Secret': process.env.HASURA_ADMIN_SECRET,
          },
        }
      ),
    ]);
    
    const currentRates = currentResponse.data.data.exchange_rates;
    const historicalRates = historicalResponse.data.data.exchange_rates;
    
    const changes = [];
    
    for (const current of currentRates) {
      const historical = historicalRates.find(h => 
        h.base_currency === current.base_currency && 
        h.target_currency === current.target_currency
      );
      
      if (historical) {
        const change = ((current.rate - historical.rate) / historical.rate) * 100;
        const changeData = {
          base_currency: current.base_currency,
          target_currency: current.target_currency,
          current_rate: current.rate,
          historical_rate: historical.rate,
          change_percent: Math.round(change * 100) / 100,
          timeframe: data.timeframe,
          calculated_at: new Date().toISOString(),
        };
        
        changes.push(changeData);
        
        // Cache the change calculation
        const changeKey = `rate:change:${data.timeframe}:${current.base_currency}:${current.target_currency}`;
        await cacheRateChange(changeKey, changeData);
      }
    }
    
    return { timeframe: data.timeframe, calculatedChanges: changes.length, changes };
  } catch (error) {
    console.error('Failed to calculate rate changes:', error);
    throw error;
  }
}

async function cleanupOldRates(data: { olderThanDays: number }) {
  console.log(`Cleaning up rate data older than ${data.olderThanDays} days`);
  
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - data.olderThanDays);
  
  try {
    const mutations = [
      'delete_exchange_rates',
      'delete_crypto_prices', 
      'delete_metal_prices'
    ];
    
    let totalDeleted = 0;
    
    for (const mutationName of mutations) {
      const mutation = `
        mutation DeleteOld${mutationName.split('_')[1]}($cutoff: timestamptz!) {
          ${mutationName}(where: { created_at: { _lt: $cutoff } }) {
            affected_rows
          }
        }
      `;
      
      try {
        const response = await axios.post(
          process.env.HASURA_ENDPOINT || 'http://hasura:8080/v1/graphql',
          { query: mutation, variables: { cutoff: cutoffDate.toISOString() } },
          {
            headers: {
              'Content-Type': 'application/json',
              'X-Hasura-Admin-Secret': process.env.HASURA_ADMIN_SECRET,
            },
          }
        );
        
        const deletedRows = response.data.data[mutationName].affected_rows;
        totalDeleted += deletedRows;
        console.log(`Deleted ${deletedRows} old ${mutationName.split('_')[1]} records`);
      } catch (error) {
        console.error(`Failed to cleanup ${mutationName}:`, error);
      }
    }
    
    return { totalDeleted, cutoffDate: cutoffDate.toISOString() };
  } catch (error) {
    console.error('Failed to cleanup old rates:', error);
    throw error;
  }
}

// Helper functions for simulated data
function generateSimulatedRate(base: string, target: string): number {
  // Generate realistic exchange rate based on currency pair
  const baseRates: { [key: string]: number } = {
    'USD': 1.0,
    'EUR': 0.85,
    'GBP': 0.73,
    'JPY': 110.0,
    'AUD': 1.35,
    'CAD': 1.25,
    'CHF': 0.92,
  };
  
  const baseRate = baseRates[base] || 1.0;
  const targetRate = baseRates[target] || 1.0;
  const rate = targetRate / baseRate;
  
  // Add some random variation (+/- 2%)
  const variation = 1 + (Math.random() - 0.5) * 0.04;
  return Math.round(rate * variation * 10000) / 10000;
}

function generateSimulatedCryptoPrice(crypto: string): number {
  const basePrices: { [key: string]: number } = {
    'BTC': 45000,
    'ETH': 3000,
    'ADA': 0.5,
    'DOT': 7.5,
    'SOL': 100,
    'AVAX': 25,
    'MATIC': 0.8,
    'LINK': 15,
    'UNI': 6,
    'ATOM': 12,
  };
  
  const basePrice = basePrices[crypto.toUpperCase()] || 1.0;
  const variation = 1 + (Math.random() - 0.5) * 0.1; // +/- 5%
  return Math.round(basePrice * variation * 100) / 100;
}

function generateSimulatedMetalPrice(metal: string): number {
  const basePrices: { [key: string]: number } = {
    'GOLD': 1950,
    'SILVER': 24,
    'PLATINUM': 1000,
    'PALLADIUM': 2300,
    'COPPER': 4.2,
    'ALUMINUM': 2.1,
  };
  
  const basePrice = basePrices[metal.toUpperCase()] || 100;
  const variation = 1 + (Math.random() - 0.5) * 0.06; // +/- 3%
  return Math.round(basePrice * variation * 100) / 100;
}

// Database storage functions
async function storeExchangeRate(data: any) {
  const mutation = `
    mutation InsertExchangeRate($data: exchange_rates_insert_input!) {
      insert_exchange_rates_one(object: $data) {
        id
      }
    }
  `;

  await axios.post(
    process.env.HASURA_ENDPOINT || 'http://hasura:8080/v1/graphql',
    { query: mutation, variables: { data: {
      base_currency: data.base_currency,
      target_currency: data.target_currency,
      rate: data.rate,
      source: data.source,
      created_at: data.timestamp.toISOString(),
    }}},
    {
      headers: {
        'Content-Type': 'application/json',
        'X-Hasura-Admin-Secret': process.env.HASURA_ADMIN_SECRET,
      },
    }
  );
}

async function storeCryptoPrice(data: any) {
  const mutation = `
    mutation InsertCryptoPrice($data: crypto_prices_insert_input!) {
      insert_crypto_prices_one(object: $data) {
        id
      }
    }
  `;

  await axios.post(
    process.env.HASURA_ENDPOINT || 'http://hasura:8080/v1/graphql',
    { query: mutation, variables: { data: {
      symbol: data.symbol,
      vs_currency: data.vs_currency,
      price: data.price,
      market_cap: data.market_cap,
      volume_24h: data.volume_24h,
      change_24h: data.change_24h,
      source: data.source,
      created_at: data.timestamp.toISOString(),
    }}},
    {
      headers: {
        'Content-Type': 'application/json',
        'X-Hasura-Admin-Secret': process.env.HASURA_ADMIN_SECRET,
      },
    }
  );
}

async function storeMetalPrice(data: any) {
  const mutation = `
    mutation InsertMetalPrice($data: metal_prices_insert_input!) {
      insert_metal_prices_one(object: $data) {
        id
      }
    }
  `;

  await axios.post(
    process.env.HASURA_ENDPOINT || 'http://hasura:8080/v1/graphql',
    { query: mutation, variables: { data: {
      metal: data.metal,
      price_per_oz: data.price_per_oz,
      currency: data.currency,
      change_24h: data.change_24h,
      source: data.source,
      created_at: data.timestamp.toISOString(),
    }}},
    {
      headers: {
        'Content-Type': 'application/json',
        'X-Hasura-Admin-Secret': process.env.HASURA_ADMIN_SECRET,
      },
    }
  );
}

// Redis caching functions
async function cacheCurrentRate(data: any) {
  const cacheKey = `rate:current:${data.base_currency}:${data.target_currency}`;
  console.log(`Would cache exchange rate with key: ${cacheKey}`, data.rate);
}

async function cacheCurrentCryptoPrice(data: any) {
  const cacheKey = `crypto:current:${data.symbol}:${data.vs_currency}`;
  console.log(`Would cache crypto price with key: ${cacheKey}`, data.price);
}

async function cacheCurrentMetalPrice(data: any) {
  const cacheKey = `metal:current:${data.metal}`;
  console.log(`Would cache metal price with key: ${cacheKey}`, data.price_per_oz);
}

async function cacheRateChange(key: string, data: any) {
  console.log(`Would cache rate change with key: ${key}`, data);
}

// Error handling
currencyWorker.on('completed', (job) => {
  console.log(`âœ… Currency job ${job.id} completed`);
});

currencyWorker.on('failed', (job, err) => {
  console.error(`âŒ Currency job ${job?.id} failed:`, err);
});

// Bull Dashboard (if enabled)
if (process.env.BULLMQ_DASHBOARD_ENABLED === 'true') {
  const serverAdapter = new ExpressAdapter();
  serverAdapter.setBasePath('/admin/queues');

  createBullBoard({
    queues: [new BullMQAdapter(currencyQueue)],
    serverAdapter,
  });

  const app = express();
  app.use('/admin/queues', serverAdapter.getRouter());
  
  const port = process.env.BULLMQ_DASHBOARD_PORT || 3201;
  app.listen(port, () => {
    console.log(`ðŸ“Š BullMQ Dashboard running on port ${port}`);
    console.log(`ðŸ’± Currency processing queue dashboard available at http://localhost:${port}/admin/queues`);
  });
}

// Schedule recurring jobs
async function setupRecurringJobs() {
  // Major fiat currencies
  const majorCurrencies = ['EUR', 'GBP', 'JPY', 'AUD', 'CAD', 'CHF', 'CNY'];
  
  // Top cryptocurrencies
  const topCryptos = ['BTC', 'ETH', 'ADA', 'DOT', 'SOL', 'AVAX', 'MATIC', 'LINK', 'UNI', 'ATOM'];
  
  // Precious metals
  const metals = ['GOLD', 'SILVER', 'PLATINUM', 'PALLADIUM'];

  // Fetch exchange rates every 5 minutes
  await currencyQueue.add(
    'fetch-exchange-rates',
    { baseCurrency: 'USD', targetCurrencies: majorCurrencies },
    {
      repeat: { pattern: '*/5 * * * *' },
      removeOnComplete: 20,
      removeOnFail: 5,
    }
  );

  // Fetch crypto prices every 2 minutes
  await currencyQueue.add(
    'fetch-crypto-prices',
    { cryptos: topCryptos, vsCurrency: 'USD' },
    {
      repeat: { pattern: '*/2 * * * *' },
      removeOnComplete: 30,
      removeOnFail: 5,
    }
  );

  // Fetch metal prices every 10 minutes
  await currencyQueue.add(
    'fetch-metal-prices',
    { metals },
    {
      repeat: { pattern: '*/10 * * * *' },
      removeOnComplete: 15,
      removeOnFail: 3,
    }
  );

  // Calculate rate changes every 15 minutes for different timeframes
  const timeframes = ['1h', '24h', '7d', '30d'];
  for (const timeframe of timeframes) {
    await currencyQueue.add(
      'calculate-rate-changes',
      { timeframe },
      {
        repeat: { pattern: '*/15 * * * *' },
        removeOnComplete: 10,
        removeOnFail: 3,
      }
    );
  }

  // Cleanup old data weekly
  await currencyQueue.add(
    'cleanup-old-rates',
    { olderThanDays: 90 },
    {
      repeat: { pattern: '0 3 * * 0' }, // Weekly on Sunday at 3 AM
      removeOnComplete: 1,
      removeOnFail: 1,
    }
  );

  console.log('ðŸ“… Recurring currency processing jobs scheduled');
}

// Initialize recurring jobs after a delay
setTimeout(setupRecurringJobs, 3000);

console.log('ðŸ’± Currency processing worker started');

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('Shutting down currency worker...');
  await currencyWorker.close();
  await currencyQueue.close();
  process.exit(0);
});