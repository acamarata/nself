import { Worker, Job, Queue } from 'bullmq';
import { createBullBoard } from '@bull-board/api';
import { BullMQAdapter } from '@bull-board/api/bullMQAdapter';
import { ExpressAdapter } from '@bull-board/express';
import express from 'express';
import axios from 'axios';

// Redis connection
const redisConfig = {
  host: process.env.REDIS_HOST || 'redis',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD || undefined,
};

// Queue for ${WORKER_NAME}
const ${WORKER_NAME}Queue = new Queue('${WORKER_NAME}', { connection: redisConfig });

// Worker for ${WORKER_NAME}
const ${WORKER_NAME}Worker = new Worker(
  '${WORKER_NAME}',
  async (job: Job) => {
    console.log(`Processing ${WORKER_NAME} job:`, job.id);
    
    const { data } = job;
    
    try {
      // Add your job processing logic here
      switch (job.name) {
        case 'process-${WORKER_NAME}':
          return await process${WORKER_NAME_CAMEL}(data);
        case 'send-notification':
          return await sendNotification(data);
        case 'cleanup-${WORKER_NAME}':
          return await cleanup${WORKER_NAME_CAMEL}(data);
        default:
          throw new Error(`Unknown job type: ${job.name}`);
      }
    } catch (error) {
      console.error(`Failed ${WORKER_NAME} job:`, job.id, error);
      throw error;
    }
  },
  { 
    connection: redisConfig,
    concurrency: 2 // Process up to 2 jobs simultaneously
  }
);

// Job processing functions
async function process${WORKER_NAME_CAMEL}(data: any) {
  console.log(`Processing ${WORKER_NAME} with data:`, data);
  
  try {
    // Example: Process data and store in database
    const processedData = {
      id: Math.random().toString(36).substr(2, 9),
      processed_at: new Date().toISOString(),
      status: 'completed',
      data: data,
    };
    
    // Store in PostgreSQL via Hasura GraphQL
    await storeProcessedData(processedData);
    
    // Cache result in Redis if needed
    await cacheResult(`${WORKER_NAME}:result:${processedData.id}`, processedData);
    
    // Simulate async work
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return { success: true, processedData };
  } catch (error) {
    console.error(`Error processing ${WORKER_NAME}:`, error);
    throw error;
  }
}

async function sendNotification(data: { type: string, message: string, recipient?: string }) {
  console.log(`Sending ${data.type} notification:`, data.message);
  
  try {
    // Example notification logic
    // This could integrate with email services, webhooks, push notifications, etc.
    const notification = {
      id: Math.random().toString(36).substr(2, 9),
      type: data.type,
      message: data.message,
      recipient: data.recipient || 'system',
      sent_at: new Date().toISOString(),
      status: 'sent',
    };
    
    // Store notification record
    await storeNotification(notification);
    
    return { success: true, notification };
  } catch (error) {
    console.error('Error sending notification:', error);
    throw error;
  }
}

async function cleanup${WORKER_NAME_CAMEL}(data: { olderThanDays: number }) {
  console.log(`Cleaning up ${WORKER_NAME} data older than ${data.olderThanDays} days`);
  
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - data.olderThanDays);
  
  try {
    // Example cleanup mutation
    const mutation = `
      mutation Cleanup${WORKER_NAME_CAMEL}Data($cutoff: timestamptz!) {
        delete_${WORKER_NAME}_data(where: { created_at: { _lt: $cutoff } }) {
          affected_rows
        }
      }
    `;
    
    const response = await axios.post(
      process.env.HASURA_ENDPOINT || 'http://hasura:8080/v1/graphql',
      { query: mutation, variables: { cutoff: cutoffDate.toISOString() } },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Hasura-Admin-Secret': process.env.HASURA_ADMIN_SECRET,
        },
      }
    );
    
    const deletedRows = response.data.data[`delete_${WORKER_NAME}_data`].affected_rows;
    return { deletedRows, cutoffDate: cutoffDate.toISOString() };
  } catch (error) {
    console.error(`Failed to cleanup ${WORKER_NAME} data:`, error);
    throw error;
  }
}

// Helper functions
async function storeProcessedData(data: any) {
  const mutation = `
    mutation InsertProcessedData($data: ${WORKER_NAME}_data_insert_input!) {
      insert_${WORKER_NAME}_data_one(object: $data) {
        id
      }
    }
  `;

  try {
    await axios.post(
      process.env.HASURA_ENDPOINT || 'http://hasura:8080/v1/graphql',
      { query: mutation, variables: { data } },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Hasura-Admin-Secret': process.env.HASURA_ADMIN_SECRET,
        },
      }
    );
  } catch (error) {
    console.error('Failed to store processed data:', error);
    throw error;
  }
}

async function storeNotification(notification: any) {
  // Store notification in database or send via external service
  console.log('Would store notification:', notification);
}

async function cacheResult(key: string, data: any) {
  // Cache result in Redis
  console.log(`Would cache result with key: ${key}`, data);
}

// Error handling
${WORKER_NAME}Worker.on('completed', (job) => {
  console.log(`âœ… ${WORKER_NAME} job ${job.id} completed`);
});

${WORKER_NAME}Worker.on('failed', (job, err) => {
  console.error(`âŒ ${WORKER_NAME} job ${job?.id} failed:`, err);
});

// Bull Dashboard (if enabled)
if (process.env.BULLMQ_DASHBOARD_ENABLED === 'true') {
  const serverAdapter = new ExpressAdapter();
  serverAdapter.setBasePath('/admin/queues');

  createBullBoard({
    queues: [new BullMQAdapter(${WORKER_NAME}Worker.opts.connection)],
    serverAdapter,
  });

  const app = express();
  app.use('/admin/queues', serverAdapter.getRouter());
  
  const port = process.env.BULLMQ_DASHBOARD_PORT || 3200;
  app.listen(port, () => {
    console.log(`ðŸ“Š BullMQ Dashboard running on port ${port}`);
  });
}

console.log(`ðŸ”„ ${WORKER_NAME} worker started`);

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('Shutting down worker...');
  await ${WORKER_NAME}Worker.close();
  process.exit(0);
});