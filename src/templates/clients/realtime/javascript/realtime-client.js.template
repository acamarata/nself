/**
 * nself Real-Time Client
 * JavaScript client for WebSocket communication
 */

class RealtimeClient {
  constructor(options = {}) {
    this.url = options.url || 'ws://localhost:{{WEBSOCKET_PORT}}';
    this.token = options.token;
    this.socket = null;
    this.listeners = {};
    this.subscriptions = new Set();
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = options.maxReconnectAttempts || 5;
    this.reconnectDelay = options.reconnectDelay || 1000;
  }

  /**
   * Connect to WebSocket server
   */
  connect() {
    return new Promise((resolve, reject) => {
      if (!this.token) {
        return reject(new Error('Authentication token required'));
      }

      const io = require('socket.io-client');

      this.socket = io(this.url, {
        auth: { token: this.token },
        transports: ['websocket', 'polling']
      });

      this.socket.on('connect', () => {
        console.log('Connected to real-time server');
        this.reconnectAttempts = 0;
        resolve();
      });

      this.socket.on('disconnect', (reason) => {
        console.log('Disconnected:', reason);
        this._handleReconnect();
      });

      this.socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
        reject(error);
      });

      // Set up event listeners
      this._setupEventListeners();
    });
  }

  /**
   * Disconnect from server
   */
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }

  /**
   * Subscribe to a channel
   */
  subscribe(channel) {
    return new Promise((resolve, reject) => {
      if (!this.socket || !this.socket.connected) {
        return reject(new Error('Not connected'));
      }

      this.socket.emit('subscribe', { channel });

      this.socket.once('subscribed', (data) => {
        if (data.channel === channel) {
          this.subscriptions.add(channel);
          resolve(data);
        }
      });

      this.socket.once('error', reject);
    });
  }

  /**
   * Unsubscribe from a channel
   */
  unsubscribe(channel) {
    return new Promise((resolve, reject) => {
      if (!this.socket) {
        return reject(new Error('Not connected'));
      }

      this.socket.emit('unsubscribe', { channel });

      this.socket.once('unsubscribed', (data) => {
        if (data.channel === channel) {
          this.subscriptions.delete(channel);
          resolve(data);
        }
      });
    });
  }

  /**
   * Send message to channel
   */
  send(channel, content, options = {}) {
    return new Promise((resolve, reject) => {
      if (!this.socket) {
        return reject(new Error('Not connected'));
      }

      this.socket.emit('message:send', {
        channel,
        content,
        messageType: options.messageType || 'text',
        metadata: options.metadata || {}
      });

      // Assuming server confirms delivery
      resolve();
    });
  }

  /**
   * Broadcast ephemeral event (typing, cursor, etc.)
   */
  broadcast(channel, eventType, payload) {
    if (!this.socket) {
      throw new Error('Not connected');
    }

    this.socket.emit('broadcast', {
      channel,
      eventType,
      payload
    });
  }

  /**
   * Update presence
   */
  updatePresence(channel, status, metadata = {}) {
    if (!this.socket) {
      throw new Error('Not connected');
    }

    this.socket.emit('presence:update', {
      channel,
      status,
      metadata
    });
  }

  /**
   * Get online users in channel
   */
  getPresence(channel) {
    return new Promise((resolve, reject) => {
      if (!this.socket) {
        return reject(new Error('Not connected'));
      }

      this.socket.emit('presence:get', { channel });

      this.socket.once('presence:list', (data) => {
        if (data.channel === channel) {
          resolve(data.users);
        }
      });
    });
  }

  /**
   * Listen for events
   */
  on(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  }

  /**
   * Remove event listener
   */
  off(event, callback) {
    if (!this.listeners[event]) return;

    if (callback) {
      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
    } else {
      delete this.listeners[event];
    }
  }

  /**
   * Setup event listeners from Socket.IO
   */
  _setupEventListeners() {
    // New message
    this.socket.on('message:new', (data) => {
      this._emit('message', data);
    });

    // User joined
    this.socket.on('user:joined', (data) => {
      this._emit('userJoined', data);
    });

    // User left
    this.socket.on('user:left', (data) => {
      this._emit('userLeft', data);
    });

    // Broadcast event (typing, cursor, etc.)
    this.socket.on('broadcast', (data) => {
      this._emit('broadcast', data);
      this._emit(`broadcast:${data.eventType}`, data);
    });

    // Presence update
    this.socket.on('presence:update', (data) => {
      this._emit('presenceUpdate', data);
    });

    // Database notification
    this.socket.on('db:notification', (data) => {
      this._emit('dbNotification', data);
    });
  }

  /**
   * Emit event to listeners
   */
  _emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(callback => callback(data));
    }
  }

  /**
   * Handle reconnection
   */
  _handleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }

    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

    console.log(`Reconnecting in ${delay}ms... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

    setTimeout(() => {
      this.connect().catch(console.error);
    }, delay);
  }
}

// Export for CommonJS and ES modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = RealtimeClient;
}

if (typeof window !== 'undefined') {
  window.RealtimeClient = RealtimeClient;
}
