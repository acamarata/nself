#####################################
# nself Configuration
# Copy this file to .env.local and update values
#
# For production deployment:
# 1. Run 'nself prod' to create production .env
# 2. Edit .env with production overrides only
# 3. Keep .env.local as your base configuration
#####################################

#####################################
# CORE PROJECT SETTINGS
# These variables are used throughout the configuration
#####################################

# Environment Mode: dev or prod
# dev = Development mode (default) - enables dev tools, mock data, debug logging
# prod = Production mode - security hardening, real data, optimized settings
# PRODUCTION: Set to "prod" in your .env override
ENV=dev

# Project Identifier
# Used for Docker container names, database names, and resource prefixes
PROJECT_NAME=myproject

# Base Domain
# All services will be subdomains of this domain
# Development: local.nself.org (with automatic SSL)
# Production: your-domain.com (configure SSL_MODE below)
# PRODUCTION: Use your real domain (e.g., api.mycompany.com)
BASE_DOMAIN=local.nself.org

# Database Seeding Strategy
# When true: Uses Hasura/PostgreSQL standard structure (common/ + environment-specific)
# When false: Uses single default/ directory for all environments
# Recommended: Follows industry standards
DB_ENV_SEEDS=true

# Legacy environment variable (for backward compatibility)
# Automatically set based on ENV: dev->development, prod->production
# Note: This is handled internally by nself, no need to set manually

#####################################
# PostgreSQL Database
#####################################
POSTGRES_VERSION=16-alpine
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_DB=nhost
POSTGRES_USER=postgres
# PRODUCTION: Generate with 'openssl rand -hex 32'
POSTGRES_PASSWORD=secretpassword
# Enable extensions (comma separated: timescaledb,postgis,pg_cron,vector,uuid-ossp)
POSTGRES_EXTENSIONS=uuid-ossp

#####################################
# Hasura GraphQL Engine
#####################################
HASURA_VERSION=v2.44.0
# PRODUCTION: Generate with 'openssl rand -hex 32'
HASURA_GRAPHQL_ADMIN_SECRET=hasura-admin-secret
# Generate a secure JWT key with: openssl rand -hex 32
# PRODUCTION: Replace key value
HASURA_GRAPHQL_JWT_SECRET='{"type":"HS256","key":"CHANGE-THIS-TO-YOUR-OWN-SECRET-KEY-MIN-32-CHARS"}'
# Auto-set to false when ENV=prod
HASURA_GRAPHQL_ENABLE_CONSOLE=true
# Auto-set to false when ENV=prod
HASURA_GRAPHQL_DEV_MODE=true
HASURA_GRAPHQL_ENABLE_TELEMETRY=false
# PRODUCTION: Set to your domain (e.g., https://myapp.com)
HASURA_GRAPHQL_CORS_DOMAIN=*
HASURA_ROUTE=api.${BASE_DOMAIN}

# Remote Schemas (optional) - uncomment to enable
# REMOTE_SCHEMA_1_NAME=app1_api
# REMOTE_SCHEMA_1_URL=https://api.app1.${BASE_DOMAIN}/graphql
# REMOTE_SCHEMA_1_HEADERS=x-api-key:your-api-key
# REMOTE_SCHEMA_2_NAME=app2_api
# REMOTE_SCHEMA_2_URL=https://api.app2.${BASE_DOMAIN}/graphql
# REMOTE_SCHEMA_2_HEADERS="authorization:Bearer your-token-here"

#####################################
# Hasura Auth Service
#####################################
AUTH_VERSION=0.36.0
AUTH_HOST=auth
AUTH_PORT=4000
# Your frontend URL
# For multiple apps, use comma-separated URLs:
# AUTH_CLIENT_URL=https://app1.${BASE_DOMAIN},https://app2.${BASE_DOMAIN},https://admin.${BASE_DOMAIN}
AUTH_CLIENT_URL=http://localhost:3000
# 30 days in seconds
AUTH_JWT_REFRESH_TOKEN_EXPIRES_IN=2592000
# 15 minutes in seconds
AUTH_JWT_ACCESS_TOKEN_EXPIRES_IN=900
AUTH_WEBAUTHN_ENABLED=false
AUTH_ROUTE=auth.${BASE_DOMAIN}

# Email Configuration
# Run 'nself email setup' for interactive configuration wizard
# Or see 'nself email list' for all supported providers
#
# Development (default - MailPit captures all emails locally):
AUTH_SMTP_HOST=mailpit
AUTH_SMTP_PORT=1025
AUTH_SMTP_USER=""
AUTH_SMTP_PASS=""
AUTH_SMTP_SECURE=false
AUTH_SMTP_SENDER=noreply@${BASE_DOMAIN}
#
# Production Examples (uncomment and configure one):
#
# SendGrid:
# AUTH_SMTP_HOST=smtp.sendgrid.net
# AUTH_SMTP_PORT=587
# AUTH_SMTP_USER=apikey
# AUTH_SMTP_PASS=your-sendgrid-api-key
# AUTH_SMTP_SECURE=true
#
# AWS SES:
# AUTH_SMTP_HOST=email-smtp.us-east-1.amazonaws.com
# AUTH_SMTP_PORT=587
# AUTH_SMTP_USER=your-smtp-username
# AUTH_SMTP_PASS=your-smtp-password
# AUTH_SMTP_SECURE=true
#
# Gmail (requires app password):
# AUTH_SMTP_HOST=smtp.gmail.com
# AUTH_SMTP_PORT=587
# AUTH_SMTP_USER=your-email@gmail.com
# AUTH_SMTP_PASS=your-app-password
# AUTH_SMTP_SECURE=true
#
# Mailgun:
# AUTH_SMTP_HOST=smtp.mailgun.org
# AUTH_SMTP_PORT=587
# AUTH_SMTP_USER=postmaster@your-domain.mailgun.org
# AUTH_SMTP_PASS=your-mailgun-password
# AUTH_SMTP_SECURE=true

#####################################
# File Storage (MinIO/S3)
#####################################
STORAGE_VERSION=0.6.1
STORAGE_ROUTE=storage.${BASE_DOMAIN}
STORAGE_CONSOLE_ROUTE=storage-console.${BASE_DOMAIN}
MINIO_VERSION=latest
MINIO_PORT=9000
# CHANGE IN PRODUCTION!
MINIO_ROOT_USER=minioadmin
# CHANGE IN PRODUCTION!
MINIO_ROOT_PASSWORD=minioadmin

# S3 Configuration
# CHANGE IN PRODUCTION!
S3_ACCESS_KEY=storage-access-key
# CHANGE IN PRODUCTION!
S3_SECRET_KEY=storage-secret-key
S3_BUCKET=nhost
S3_REGION=us-east-1

#####################################
# Nginx Proxy Configuration
#####################################
NGINX_VERSION=alpine
NGINX_HTTP_PORT=80
NGINX_HTTPS_PORT=443

#####################################
# SSL/TLS Configuration
#####################################
# SSL Modes:
# - local: Uses pre-generated local certificates for *.nself.org
# - letsencrypt: Automatic Let's Encrypt certificates (production)
# - custom: Use your own certificates
# - none: No SSL (not recommended)
SSL_MODE=local

# Let's Encrypt Configuration (when SSL_MODE=letsencrypt)
# LETSENCRYPT_EMAIL=admin@yourdomain.com
# Set to false for real certificates
# LETSENCRYPT_STAGING=true

# Custom SSL Configuration (when SSL_MODE=custom)
# SSL_CERT_PATH=/path/to/cert.pem
# SSL_KEY_PATH=/path/to/key.pem

#####################################
# Optional Services
# Enable/disable additional services
#####################################

# Functions Service (Serverless functions)
FUNCTIONS_ENABLED=false
FUNCTIONS_ROUTE=functions.${BASE_DOMAIN}

# Dashboard (Admin UI)
DASHBOARD_ENABLED=false
DASHBOARD_VERSION=latest
DASHBOARD_ROUTE=dashboard.${BASE_DOMAIN}

# Redis Cache
REDIS_ENABLED=false
REDIS_VERSION=7-alpine
REDIS_PORT=6379
# Set password in production
REDIS_PASSWORD=""

# Email Testing (MailPit for development)
# Options: mailpit, none
EMAIL_PROVIDER=mailpit
MAILPIT_SMTP_PORT=1025
MAILPIT_UI_PORT=8025
MAILPIT_ROUTE=mail.${BASE_DOMAIN}
EMAIL_FROM=noreply@${BASE_DOMAIN}

#####################################
# Microservices Configuration
# Enable different backend service frameworks
#####################################
SERVICES_ENABLED=false

# NestJS Services
NESTJS_ENABLED=false
# Comma-separated list of services (e.g., api,worker,admin)
NESTJS_SERVICES=""
# Use TypeScript (true) or JavaScript (false)
NESTJS_USE_TYPESCRIPT=true
# Starting port for NestJS services
NESTJS_PORT_START=3100

# BullMQ Workers (Background jobs)
BULLMQ_ENABLED=false
# Comma-separated list of workers (e.g., email,notifications,cleanup)
BULLMQ_WORKERS=""
BULLMQ_DASHBOARD_ENABLED=false
BULLMQ_DASHBOARD_PORT=3200
BULLMQ_DASHBOARD_ROUTE=queues.${BASE_DOMAIN}

# GoLang Services
GOLANG_ENABLED=false
# Comma-separated list of services (e.g., grpc,websocket)
GOLANG_SERVICES=""
# Starting port for Go services
GOLANG_PORT_START=3300

# Python Services
PYTHON_ENABLED=false
# Comma-separated list of services (e.g., ml,analytics)
PYTHON_SERVICES=""
# Options: fastapi, flask, django
PYTHON_FRAMEWORK=fastapi
# Starting port for Python services
PYTHON_PORT_START=3400

# NestJS Always-Running Service
NESTJS_RUN_ENABLED=false
NESTJS_RUN_PORT=3500

#####################################
# Advanced Configuration
# Usually no need to modify these
#####################################

# Hasura Metadata
HASURA_METADATA_DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}

# Docker Network
DOCKER_NETWORK=${PROJECT_NAME}_network

# Internal Ports (rarely need to change)
HASURA_PORT=8080
HASURA_CONSOLE_PORT=9695
FUNCTIONS_PORT=3000
DASHBOARD_PORT=3000
CONFIG_SERVER_PORT=4001

# Service Aliases (for backward compatibility)
S3_ENDPOINT=http://minio:${MINIO_PORT}
FILES_ROUTE=files.${BASE_DOMAIN}
MAIL_ROUTE=mail.${BASE_DOMAIN}
MAILHOG_ROUTE=mailhog.${BASE_DOMAIN}

#####################################
# Application-Specific Routes
# Add custom app routing below
#####################################

# Example: Custom Application Routes
# Format: port:subdomain.${BASE_DOMAIN}
# These create nginx reverse proxy configs automatically
#
# Example: APP_1_ROUTE=3000:app.${BASE_DOMAIN} creates nginx/conf.d/app.conf
#
# APP_1_ROUTE=3000:app.${BASE_DOMAIN}
# APP_2_ROUTE=3001:admin.${BASE_DOMAIN}
# APP_3_ROUTE=5173:dev.${BASE_DOMAIN}
# APP_4_ROUTE=8080:api-docs.${BASE_DOMAIN}
# APP_5_ROUTE=3002:dashboard.${BASE_DOMAIN}
# APP_6_ROUTE=4200:angular-app.${BASE_DOMAIN}
# APP_7_ROUTE=8000:django-app.${BASE_DOMAIN}

#####################################
# End of Configuration
# Run 'nself build' after editing
#####################################