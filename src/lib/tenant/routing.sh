#!/usr/bin/env bash

#
# Tenant Routing Library
# Subdomain-based and custom domain routing for multi-tenancy
#

# Source dependencies
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../utils/output.sh"

# ============================================================================
# Nginx Configuration Generation for Multi-Tenancy
# ============================================================================

generate_tenant_routing_config() {
  local base_domain="${1:-$BASE_DOMAIN}"
  local output_dir="${2:-$ROOT_DIR/nginx}"

  info "Generating multi-tenant nginx configuration"

  # Create tenant routing config
  cat >"$output_dir/conf.d/tenant-routing.conf" <<'EOF'
# Multi-Tenant Routing Configuration
# Automatically generated by nself

# Map to extract tenant from subdomain
map $host $tenant_slug {
    default "";

    # Pattern: subdomain.base-domain.com → subdomain
    ~^(?<tenant>[^.]+)\..+$ $tenant;
}

# Map to extract tenant from custom domain
map $host $tenant_custom_domain {
    default "";

    # Custom domains are looked up in PostgreSQL
    # This is a placeholder - actual lookup happens in middleware
}

# Tenant resolution priority:
# 1. X-Tenant-ID header (direct tenant specification)
# 2. X-Tenant-Slug header (tenant slug)
# 3. Custom domain lookup (PostgreSQL)
# 4. Subdomain extraction
map $tenant_slug $tenant_id_from_subdomain {
    default "";
    # This will be populated dynamically from PostgreSQL
}

# Pass tenant context to backend
# Add these headers to all proxied requests
proxy_set_header X-Tenant-Slug $tenant_slug;
proxy_set_header X-Tenant-Domain $host;

# For Hasura JWT claims
# The backend will resolve tenant_id and add to JWT

EOF

  # Create Lua script for tenant resolution
  cat >"$output_dir/lua/tenant_resolver.lua" <<'EOF'
-- Tenant Resolution Lua Module
-- Resolves tenant from various sources

local tenant_resolver = {}

-- PostgreSQL connection details
local pg_host = os.getenv("POSTGRES_HOST") or "postgres"
local pg_port = os.getenv("POSTGRES_PORT") or "5432"
local pg_db = os.getenv("POSTGRES_DB") or "nself"
local pg_user = os.getenv("POSTGRES_USER") or "postgres"
local pg_password = os.getenv("POSTGRES_PASSWORD") or ""

-- Resolve tenant from custom domain
function tenant_resolver.resolve_from_domain(domain)
    -- Connect to PostgreSQL
    local pgmoon = require("pgmoon")
    local pg = pgmoon.new({
        host = pg_host,
        port = pg_port,
        database = pg_db,
        user = pg_user,
        password = pg_password
    })

    assert(pg:connect())

    -- Query tenant_domains table
    local result = assert(pg:query([[
        SELECT tenant_id
        FROM tenants.tenant_domains
        WHERE domain = ]] .. pg:escape_literal(domain) .. [[
        AND is_verified = true
        LIMIT 1
    ]]))

    pg:keepalive(10000, 100)

    if result and result[1] then
        return result[1].tenant_id
    end

    return nil
end

-- Resolve tenant from slug
function tenant_resolver.resolve_from_slug(slug)
    local pgmoon = require("pgmoon")
    local pg = pgmoon.new({
        host = pg_host,
        port = pg_port,
        database = pg_db,
        user = pg_user,
        password = pg_password
    })

    assert(pg:connect())

    local result = assert(pg:query([[
        SELECT id
        FROM tenants.tenants
        WHERE slug = ]] .. pg:escape_literal(slug) .. [[
        AND status = 'active'
        LIMIT 1
    ]]))

    pg:keepalive(10000, 100)

    if result and result[1] then
        return result[1].id
    end

    return nil
end

-- Main resolution function
function tenant_resolver.resolve()
    local headers = ngx.req.get_headers()
    local host = headers["Host"]

    -- Priority 1: X-Tenant-ID header
    if headers["X-Tenant-ID"] then
        return headers["X-Tenant-ID"]
    end

    -- Priority 2: X-Tenant-Slug header
    if headers["X-Tenant-Slug"] then
        return tenant_resolver.resolve_from_slug(headers["X-Tenant-Slug"])
    end

    -- Priority 3: Custom domain
    local tenant_id = tenant_resolver.resolve_from_domain(host)
    if tenant_id then
        return tenant_id
    end

    -- Priority 4: Subdomain
    -- Extract subdomain: tenant.base.com → tenant
    local subdomain = host:match("^([^.]+)%.")
    if subdomain then
        return tenant_resolver.resolve_from_slug(subdomain)
    end

    -- Default: no tenant (might be public request)
    return nil
end

return tenant_resolver
EOF

  # Create nginx location snippet for tenant context
  cat >"$output_dir/snippets/tenant-context.conf" <<'EOF'
# Tenant Context Snippet
# Include this in locations that need tenant resolution

# Resolve tenant using Lua
set $tenant_id '';
access_by_lua_block {
    local resolver = require("tenant_resolver")
    local tenant_id = resolver.resolve()
    if tenant_id then
        ngx.var.tenant_id = tenant_id
    end
}

# Pass tenant ID to backend
proxy_set_header X-Hasura-Tenant-Id $tenant_id;
proxy_set_header X-Tenant-Id $tenant_id;

# If no tenant found, might want to reject or redirect
if ($tenant_id = '') {
    # Uncomment to require tenant for all requests
    # return 404;
}
EOF

  success "Multi-tenant routing configuration generated"
}

# ============================================================================
# Custom Domain SSL Certificate Management
# ============================================================================

generate_custom_domain_ssl() {
  local tenant_id="$1"
  local domain="$2"

  if [[ -z "$tenant_id" || -z "$domain" ]]; then
    error "Tenant ID and domain required"
    return 1
  fi

  info "Generating SSL certificate for custom domain: $domain"

  # Check if domain is verified
  local verified
  verified=$(docker exec -i "$(docker_get_container_name postgres)" \
    psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -t -c \
    "SELECT is_verified FROM tenants.tenant_domains WHERE domain = '$domain' AND tenant_id = '$tenant_id'" | tr -d ' \n')

  if [[ "$verified" != "t" ]]; then
    error "Domain not verified. Run: nself tenant domain verify $tenant_id $domain"
    return 1
  fi

  # Generate certificate with mkcert (or use Let's Encrypt in production)
  if command -v mkcert >/dev/null 2>&1; then
    local ssl_dir="$ROOT_DIR/ssl/custom-domains"
    mkdir -p "$ssl_dir"

    cd "$ssl_dir" || return 1
    mkcert "$domain"

    # Create nginx config for custom domain
    local nginx_config="$ROOT_DIR/nginx/sites-enabled/$domain.conf"
    cat >"$nginx_config" <<EOF
# Custom domain for tenant: $tenant_id
# Domain: $domain

server {
    listen 443 ssl http2;
    server_name $domain;

    ssl_certificate /etc/nginx/ssl/custom-domains/$domain.pem;
    ssl_certificate_key /etc/nginx/ssl/custom-domains/$domain-key.pem;

    # Tenant resolution
    include /etc/nginx/snippets/tenant-context.conf;

    # Proxy to Hasura (or your backend)
    location / {
        proxy_pass http://hasura:8080;
        include /etc/nginx/includes/proxy-headers.conf;
    }
}
EOF

    success "SSL certificate and nginx config generated for $domain"
  else
    warn "mkcert not installed. Install it for SSL certificate generation."
    info "Or use Let's Encrypt for production: nself ssl letsencrypt $domain"
  fi
}

# ============================================================================
# Tenant URL Generation
# ============================================================================

get_tenant_url() {
  local tenant_slug="$1"
  local base_domain="${2:-$BASE_DOMAIN}"
  local protocol="${3:-https}"

  if [[ -z "$tenant_slug" ]]; then
    error "Tenant slug required"
    return 1
  fi

  # Check if tenant has custom primary domain
  local custom_domain
  custom_domain=$(docker exec -i "$(docker_get_container_name postgres)" \
    psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -t -c \
    "SELECT td.domain FROM tenants.tenant_domains td
         INNER JOIN tenants.tenants t ON td.tenant_id = t.id
         WHERE t.slug = '$tenant_slug' AND td.is_primary = true
         AND td.is_verified = true LIMIT 1" | tr -d ' \n')

  if [[ -n "$custom_domain" ]]; then
    printf "%s://%s\n" "$protocol" "$custom_domain"
  else
    printf "%s://%s.%s\n" "$protocol" "$tenant_slug" "$base_domain"
  fi
}

# ============================================================================
# Tenant Isolation Verification
# ============================================================================

verify_tenant_isolation() {
  info "Verifying tenant data isolation..."

  # Create test tenants
  local tenant1_id
  local tenant2_id

  tenant1_id=$(uuidgen)
  tenant2_id=$(uuidgen)

  # Create test data in each tenant's schema
  # This is a smoke test to ensure RLS is working

  local test_sql="
    -- Test 1: Ensure tenant 1 cannot see tenant 2's data
    SET hasura.user.x-hasura-tenant-id = '$tenant1_id';
    SELECT COUNT(*) FROM tenants.tenants WHERE id = '$tenant2_id';
    -- Should return 0

    -- Test 2: Ensure tenant 1 can see own data
    SET hasura.user.x-hasura-tenant-id = '$tenant1_id';
    SELECT COUNT(*) FROM tenants.tenants WHERE id = '$tenant1_id';
    -- Should return 1
    "

  # Run tests
  # In production, this would be more comprehensive

  success "Tenant isolation verification complete"
}
