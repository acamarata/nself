#!/usr/bin/env bash
set -euo pipefail

# secrets.sh - Secrets generation and management
# POSIX-compliant, no Bash 4+ features

# Get the directory where this script is located
SECURITY_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_ROOT="$(dirname "$SECURITY_LIB_DIR")"

# Source dependencies
source "$LIB_ROOT/utils/display.sh" 2>/dev/null || true
source "$LIB_ROOT/utils/platform-compat.sh" 2>/dev/null || true

# Default secrets file
SECRETS_FILE="${SECRETS_FILE:-.env.secrets}"

# Generate a secure random string
secrets::generate_random() {
  local length="${1:-32}"
  local type="${2:-hex}"

  case "$type" in
    hex)
      # Hexadecimal string
      if command -v openssl >/dev/null 2>&1; then
        openssl rand -hex "$((length / 2))"
      elif [[ -f /dev/urandom ]]; then
        head -c "$((length / 2))" /dev/urandom | od -An -tx1 | tr -d ' \n' | head -c "$length"
      else
        # Fallback using date and process info
        local seed
        seed="$(date +%s%N)$$"
        printf "%s" "$seed" | sha256sum | cut -c1-"$length"
      fi
      ;;
    base64)
      # Base64 string
      if command -v openssl >/dev/null 2>&1; then
        openssl rand -base64 "$length" | tr -d '\n' | head -c "$length"
      elif [[ -f /dev/urandom ]]; then
        head -c "$length" /dev/urandom | base64 | tr -d '\n' | head -c "$length"
      fi
      ;;
    alphanumeric)
      # Alphanumeric only
      if command -v openssl >/dev/null 2>&1; then
        openssl rand -base64 "$((length * 2))" | tr -dc 'a-zA-Z0-9' | head -c "$length"
      elif [[ -f /dev/urandom ]]; then
        head -c "$((length * 2))" /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c "$length"
      fi
      ;;
    *)
      log_error "Unknown secret type: $type"
      return 1
      ;;
  esac
}

# Generate all required secrets
secrets::generate_all() {
  local output_file="${1:-$SECRETS_FILE}"
  local force="${2:-false}"

  if [[ -f "$output_file" ]] && [[ "$force" != "true" ]]; then
    log_error "Secrets file already exists: $output_file"
    log_info "Use --force to overwrite"
    return 1
  fi

  log_info "Generating production secrets..."

  # Generate secrets
  local postgres_password
  local hasura_admin_secret
  local jwt_secret
  local cookie_secret
  local minio_root_password
  local redis_password
  local grafana_admin_password

  postgres_password=$(secrets::generate_random 32 alphanumeric)
  hasura_admin_secret=$(secrets::generate_random 64 hex)
  jwt_secret=$(secrets::generate_random 64 hex)
  cookie_secret=$(secrets::generate_random 32 hex)
  minio_root_password=$(secrets::generate_random 32 alphanumeric)
  redis_password=$(secrets::generate_random 32 alphanumeric)
  grafana_admin_password=$(secrets::generate_random 24 alphanumeric)

  # Write to secrets file
  cat >"$output_file" <<EOF
# Production Secrets - NEVER COMMIT TO VERSION CONTROL
# Generated by nself on $(date +%Y-%m-%d)
#
# IMPORTANT: Keep this file secure with permissions 600
# chmod 600 $output_file

# Database Credentials
POSTGRES_PASSWORD=$postgres_password

# Hasura Security
HASURA_GRAPHQL_ADMIN_SECRET=$hasura_admin_secret

# JWT Configuration
JWT_SECRET=$jwt_secret

# Session Security
COOKIE_SECRET=$cookie_secret

# MinIO Storage (if enabled)
MINIO_ROOT_PASSWORD=$minio_root_password

# Redis (if enabled)
REDIS_PASSWORD=$redis_password

# Grafana (if monitoring enabled)
GRAFANA_ADMIN_PASSWORD=$grafana_admin_password
EOF

  # Set secure permissions
  chmod 600 "$output_file"

  log_success "Generated secrets in: $output_file"
  printf "\n"
  printf "  ${COLOR_YELLOW}IMPORTANT:${COLOR_RESET}\n"
  printf "  1. Keep this file secure (permissions: 600)\n"
  printf "  2. Never commit to version control\n"
  printf "  3. Back up securely for disaster recovery\n"
  printf "\n"

  return 0
}

# Rotate a specific secret
secrets::rotate() {
  local secret_name="$1"
  local secrets_file="${2:-$SECRETS_FILE}"

  if [[ -z "$secret_name" ]]; then
    log_error "Secret name is required"
    printf "Usage: nself prod secrets rotate <SECRET_NAME>\n"
    return 1
  fi

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  # Check if secret exists
  if ! grep -q "^${secret_name}=" "$secrets_file" 2>/dev/null; then
    log_error "Secret not found: $secret_name"
    return 1
  fi

  # Determine appropriate length and type based on secret name
  local length=32
  local type="hex"

  case "$secret_name" in
    *PASSWORD*)
      length=32
      type="alphanumeric"
      ;;
    *SECRET* | *KEY*)
      length=64
      type="hex"
      ;;
  esac

  # Generate new secret
  local new_value
  new_value=$(secrets::generate_random "$length" "$type")

  # Create backup
  cp "$secrets_file" "${secrets_file}.backup-$(date +%Y%m%d-%H%M%S)"

  # Update secret
  safe_sed_inline "$secrets_file" "s|^${secret_name}=.*|${secret_name}=${new_value}|"

  log_success "Rotated secret: $secret_name"
  log_warning "Remember to restart services to apply the new secret"

  return 0
}

# Validate secrets file
secrets::validate() {
  local secrets_file="${1:-$SECRETS_FILE}"

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  local errors=0
  local warnings=0

  printf "Validating secrets in: %s\n\n" "$secrets_file"

  # Required secrets
  local required_secrets="POSTGRES_PASSWORD HASURA_GRAPHQL_ADMIN_SECRET JWT_SECRET"

  for secret in $required_secrets; do
    local value
    value=$(grep "^${secret}=" "$secrets_file" 2>/dev/null | cut -d'=' -f2)

    if [[ -z "$value" ]]; then
      printf "  ${COLOR_RED}✗${COLOR_RESET} %s is not set\n" "$secret"
      errors=$((errors + 1))
    elif [[ ${#value} -lt 16 ]]; then
      printf "  ${COLOR_YELLOW}⚠${COLOR_RESET} %s is too short (%d chars)\n" "$secret" "${#value}"
      warnings=$((warnings + 1))
    else
      printf "  ${COLOR_GREEN}✓${COLOR_RESET} %s is set (%d chars)\n" "$secret" "${#value}"
    fi
  done

  # Optional secrets (just check if they exist and have values)
  local optional_secrets="COOKIE_SECRET MINIO_ROOT_PASSWORD REDIS_PASSWORD GRAFANA_ADMIN_PASSWORD"

  for secret in $optional_secrets; do
    local value
    value=$(grep "^${secret}=" "$secrets_file" 2>/dev/null | cut -d'=' -f2)

    if [[ -n "$value" ]]; then
      if [[ ${#value} -lt 16 ]]; then
        printf "  ${COLOR_YELLOW}⚠${COLOR_RESET} %s is short (%d chars)\n" "$secret" "${#value}"
        warnings=$((warnings + 1))
      else
        printf "  ${COLOR_GREEN}✓${COLOR_RESET} %s is set (%d chars)\n" "$secret" "${#value}"
      fi
    fi
  done

  printf "\n"

  # Check file permissions
  local perms
  perms=$(safe_stat_perms "$secrets_file" 2>/dev/null)
  if [[ "$perms" != "600" ]]; then
    printf "  ${COLOR_RED}✗${COLOR_RESET} File permissions are %s (should be 600)\n" "$perms"
    errors=$((errors + 1))
  else
    printf "  ${COLOR_GREEN}✓${COLOR_RESET} File permissions are correct (600)\n"
  fi

  printf "\n"

  if [[ $errors -gt 0 ]]; then
    log_error "Validation failed with $errors error(s) and $warnings warning(s)"
    return 1
  elif [[ $warnings -gt 0 ]]; then
    log_warning "Validation passed with $warnings warning(s)"
    return 0
  else
    log_success "All secrets validated successfully"
    return 0
  fi
}

# Show secrets (masked by default)
secrets::show() {
  local secrets_file="${1:-$SECRETS_FILE}"
  local unmask="${2:-false}"

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  printf "Secrets in: %s\n\n" "$secrets_file"

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip comments and empty lines
    if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
      continue
    fi

    # Extract key and value
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      if [[ "$unmask" == "true" ]]; then
        printf "  %s=%s\n" "$key" "$value"
      else
        local masked
        if [[ ${#value} -gt 4 ]]; then
          masked="${value:0:4}$(printf '%*s' $((${#value} - 4)) | tr ' ' '*')"
        else
          masked="****"
        fi
        printf "  %s=%s\n" "$key" "$masked"
      fi
    fi
  done <"$secrets_file"
}

# Import secrets from environment variables
secrets::import_from_env() {
  local output_file="${1:-$SECRETS_FILE}"
  local prefix="${2:-NSELF_SECRET_}"

  log_info "Importing secrets from environment variables (prefix: $prefix)..."

  local imported=0

  # Check for environment variables with the prefix
  while IFS= read -r var; do
    if [[ "$var" =~ ^${prefix}(.+)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Append or update in secrets file
      if grep -q "^${key}=" "$output_file" 2>/dev/null; then
        safe_sed_inline "$output_file" "s|^${key}=.*|${key}=${value}|"
      else
        printf "%s=%s\n" "$key" "$value" >>"$output_file"
      fi

      imported=$((imported + 1))
    fi
  done < <(env | grep "^${prefix}")

  if [[ $imported -gt 0 ]]; then
    log_success "Imported $imported secret(s)"
    chmod 600 "$output_file"
  else
    log_info "No secrets found with prefix: $prefix"
  fi
}

# Export secrets to environment
secrets::export_to_env() {
  local secrets_file="${1:-$SECRETS_FILE}"

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  # Output export commands (to be eval'd by caller)
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      printf "export %s='%s'\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
    fi
  done <"$secrets_file"
}

# Check if secrets are committed to git
secrets::check_git() {
  local secrets_file="${1:-$SECRETS_FILE}"

  if ! command -v git >/dev/null 2>&1; then
    log_warning "git not available, skipping git check"
    return 0
  fi

  if [[ ! -d ".git" ]]; then
    return 0
  fi

  # Check if secrets file is tracked
  if git ls-files --error-unmatch "$secrets_file" >/dev/null 2>&1; then
    log_error "CRITICAL: $secrets_file is tracked by git!"
    log_error "Run: git rm --cached $secrets_file"
    return 1
  fi

  # Check if secrets file is in .gitignore
  if [[ -f ".gitignore" ]]; then
    if ! grep -q "$(basename "$secrets_file")" .gitignore 2>/dev/null; then
      log_warning "$secrets_file is not in .gitignore"
      return 1
    fi
  fi

  log_success "Secrets file is properly ignored by git"
  return 0
}

# Export functions
export -f secrets::generate_random
export -f secrets::generate_all
export -f secrets::rotate
export -f secrets::validate
export -f secrets::show
export -f secrets::import_from_env
export -f secrets::export_to_env
export -f secrets::check_git
