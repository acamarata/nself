#!/usr/bin/env bash

# secrets.sh - Secrets generation and management
# POSIX-compliant, no Bash 4+ features

# Get the directory where this script is located
SECURITY_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_ROOT="$(dirname "$SECURITY_LIB_DIR")"

# Source dependencies
source "$LIB_ROOT/utils/display.sh" 2>/dev/null || true
source "$LIB_ROOT/utils/platform-compat.sh" 2>/dev/null || true

# Default secrets file
SECRETS_FILE="${SECRETS_FILE:-.env.secrets}"

# Generate a secure random string
secrets::generate_random() {
  local length="${1:-32}"
  local type="${2:-hex}"

  case "$type" in
    hex)
      # Hexadecimal string
      if command -v openssl >/dev/null 2>&1; then
        openssl rand -hex "$((length / 2))"
      elif [[ -f /dev/urandom ]]; then
        head -c "$((length / 2))" /dev/urandom | od -An -tx1 | tr -d ' \n' | head -c "$length"
      else
        # Fallback using date and process info
        local seed
        seed="$(date +%s%N)$$"
        printf "%s" "$seed" | sha256sum | cut -c1-"$length"
      fi
      ;;
    base64)
      # Base64 string
      if command -v openssl >/dev/null 2>&1; then
        openssl rand -base64 "$length" | tr -d '\n' | head -c "$length"
      elif [[ -f /dev/urandom ]]; then
        head -c "$length" /dev/urandom | base64 | tr -d '\n' | head -c "$length"
      fi
      ;;
    alphanumeric)
      # Alphanumeric only
      if command -v openssl >/dev/null 2>&1; then
        openssl rand -base64 "$((length * 2))" | tr -dc 'a-zA-Z0-9' | head -c "$length"
      elif [[ -f /dev/urandom ]]; then
        head -c "$((length * 2))" /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c "$length"
      fi
      ;;
    *)
      log_error "Unknown secret type: $type"
      return 1
      ;;
  esac
}

# Generate all required secrets
secrets::generate_all() {
  local output_file="${1:-$SECRETS_FILE}"
  local force="${2:-false}"

  if [[ -f "$output_file" ]] && [[ "$force" != "true" ]]; then
    log_error "Secrets file already exists: $output_file"
    log_info "Use --force to overwrite"
    return 1
  fi

  log_info "Generating production secrets..."

  # Generate secrets
  local postgres_password
  local hasura_admin_secret
  local jwt_secret
  local cookie_secret
  local minio_root_password
  local redis_password
  local grafana_admin_password

  postgres_password=$(secrets::generate_random 32 alphanumeric)
  hasura_admin_secret=$(secrets::generate_random 64 hex)
  jwt_secret=$(secrets::generate_random 64 hex)
  cookie_secret=$(secrets::generate_random 32 hex)
  minio_root_password=$(secrets::generate_random 32 alphanumeric)
  redis_password=$(secrets::generate_random 32 alphanumeric)
  grafana_admin_password=$(secrets::generate_random 24 alphanumeric)

  # Write to secrets file
  cat >"$output_file" <<EOF
# Production Secrets - NEVER COMMIT TO VERSION CONTROL
# Generated by nself on $(date +%Y-%m-%d)
#
# IMPORTANT: Keep this file secure with permissions 600
# chmod 600 $output_file

# Database Credentials
POSTGRES_PASSWORD=$postgres_password

# Hasura Security
HASURA_GRAPHQL_ADMIN_SECRET=$hasura_admin_secret

# JWT Configuration
JWT_SECRET=$jwt_secret

# Session Security
COOKIE_SECRET=$cookie_secret

# MinIO Storage (if enabled)
MINIO_ROOT_PASSWORD=$minio_root_password

# Redis (if enabled)
REDIS_PASSWORD=$redis_password

# Grafana (if monitoring enabled)
GRAFANA_ADMIN_PASSWORD=$grafana_admin_password
EOF

  # Set secure permissions
  chmod 600 "$output_file"

  log_success "Generated secrets in: $output_file"
  printf "\n"
  printf "  ${COLOR_YELLOW}IMPORTANT:${COLOR_RESET}\n"
  printf "  1. Keep this file secure (permissions: 600)\n"
  printf "  2. Never commit to version control\n"
  printf "  3. Back up securely for disaster recovery\n"
  printf "\n"

  return 0
}

# Rotate a specific secret
secrets::rotate() {
  local secret_name="$1"
  local secrets_file="${2:-$SECRETS_FILE}"

  if [[ -z "$secret_name" ]]; then
    log_error "Secret name is required"
    printf "Usage: nself prod secrets rotate <SECRET_NAME>\n"
    return 1
  fi

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  # Check if secret exists
  if ! grep -q "^${secret_name}=" "$secrets_file" 2>/dev/null; then
    log_error "Secret not found: $secret_name"
    return 1
  fi

  # Determine appropriate length and type based on secret name
  local length=32
  local type="hex"

  case "$secret_name" in
    *PASSWORD*)
      length=32
      type="alphanumeric"
      ;;
    *SECRET* | *KEY*)
      length=64
      type="hex"
      ;;
  esac

  # Generate new secret
  local new_value
  new_value=$(secrets::generate_random "$length" "$type")

  # Create backup
  cp "$secrets_file" "${secrets_file}.backup-$(date +%Y%m%d-%H%M%S)"

  # Update secret
  safe_sed_inline "$secrets_file" "s|^${secret_name}=.*|${secret_name}=${new_value}|"

  log_success "Rotated secret: $secret_name"
  log_warning "Remember to restart services to apply the new secret"

  return 0
}

# Validate secrets file
secrets::validate() {
  local secrets_file="${1:-$SECRETS_FILE}"

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  local errors=0
  local warnings=0

  printf "Validating secrets in: %s\n\n" "$secrets_file"

  # Required secrets
  local required_secrets="POSTGRES_PASSWORD HASURA_GRAPHQL_ADMIN_SECRET JWT_SECRET"

  for secret in $required_secrets; do
    local value
    value=$(grep "^${secret}=" "$secrets_file" 2>/dev/null | cut -d'=' -f2)

    if [[ -z "$value" ]]; then
      printf "  ${COLOR_RED}✗${COLOR_RESET} %s is not set\n" "$secret"
      errors=$((errors + 1))
    elif [[ ${#value} -lt 16 ]]; then
      printf "  ${COLOR_YELLOW}⚠${COLOR_RESET} %s is too short (%d chars)\n" "$secret" "${#value}"
      warnings=$((warnings + 1))
    else
      printf "  ${COLOR_GREEN}✓${COLOR_RESET} %s is set (%d chars)\n" "$secret" "${#value}"
    fi
  done

  # Optional secrets (just check if they exist and have values)
  local optional_secrets="COOKIE_SECRET MINIO_ROOT_PASSWORD REDIS_PASSWORD GRAFANA_ADMIN_PASSWORD"

  for secret in $optional_secrets; do
    local value
    value=$(grep "^${secret}=" "$secrets_file" 2>/dev/null | cut -d'=' -f2)

    if [[ -n "$value" ]]; then
      if [[ ${#value} -lt 16 ]]; then
        printf "  ${COLOR_YELLOW}⚠${COLOR_RESET} %s is short (%d chars)\n" "$secret" "${#value}"
        warnings=$((warnings + 1))
      else
        printf "  ${COLOR_GREEN}✓${COLOR_RESET} %s is set (%d chars)\n" "$secret" "${#value}"
      fi
    fi
  done

  printf "\n"

  # Check file permissions
  local perms
  perms=$(safe_stat_perms "$secrets_file" 2>/dev/null)
  if [[ "$perms" != "600" ]]; then
    printf "  ${COLOR_RED}✗${COLOR_RESET} File permissions are %s (should be 600)\n" "$perms"
    errors=$((errors + 1))
  else
    printf "  ${COLOR_GREEN}✓${COLOR_RESET} File permissions are correct (600)\n"
  fi

  printf "\n"

  if [[ $errors -gt 0 ]]; then
    log_error "Validation failed with $errors error(s) and $warnings warning(s)"
    return 1
  elif [[ $warnings -gt 0 ]]; then
    log_warning "Validation passed with $warnings warning(s)"
    return 0
  else
    log_success "All secrets validated successfully"
    return 0
  fi
}

# Show secrets (masked by default)
secrets::show() {
  local secrets_file="${1:-$SECRETS_FILE}"
  local unmask="${2:-false}"

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  printf "Secrets in: %s\n\n" "$secrets_file"

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip comments and empty lines
    if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
      continue
    fi

    # Extract key and value
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      if [[ "$unmask" == "true" ]]; then
        printf "  %s=%s\n" "$key" "$value"
      else
        local masked
        if [[ ${#value} -gt 4 ]]; then
          masked="${value:0:4}$(printf '%*s' $((${#value} - 4)) | tr ' ' '*')"
        else
          masked="****"
        fi
        printf "  %s=%s\n" "$key" "$masked"
      fi
    fi
  done <"$secrets_file"
}

# Import secrets from environment variables
secrets::import_from_env() {
  local output_file="${1:-$SECRETS_FILE}"
  local prefix="${2:-NSELF_SECRET_}"

  log_info "Importing secrets from environment variables (prefix: $prefix)..."

  local imported=0

  # Check for environment variables with the prefix
  while IFS= read -r var; do
    if [[ "$var" =~ ^${prefix}(.+)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Append or update in secrets file
      if grep -q "^${key}=" "$output_file" 2>/dev/null; then
        safe_sed_inline "$output_file" "s|^${key}=.*|${key}=${value}|"
      else
        printf "%s=%s\n" "$key" "$value" >>"$output_file"
      fi

      imported=$((imported + 1))
    fi
  done < <(env | grep "^${prefix}")

  if [[ $imported -gt 0 ]]; then
    log_success "Imported $imported secret(s)"
    chmod 600 "$output_file"
  else
    log_info "No secrets found with prefix: $prefix"
  fi
}

# Export secrets to environment
secrets::export_to_env() {
  local secrets_file="${1:-$SECRETS_FILE}"

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  # Output export commands (to be eval'd by caller)
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      printf "export %s='%s'\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
    fi
  done <"$secrets_file"
}

# Check if secrets are committed to git
secrets::check_git() {
  local secrets_file="${1:-$SECRETS_FILE}"

  if ! command -v git >/dev/null 2>&1; then
    log_warning "git not available, skipping git check"
    return 0
  fi

  if [[ ! -d ".git" ]]; then
    return 0
  fi

  # Check if secrets file is tracked
  if git ls-files --error-unmatch "$secrets_file" >/dev/null 2>&1; then
    log_error "CRITICAL: $secrets_file is tracked by git!"
    log_error "Run: git rm --cached $secrets_file"
    return 1
  fi

  # Check if secrets file is in .gitignore
  if [[ -f ".gitignore" ]]; then
    if ! grep -q "$(basename "$secrets_file")" .gitignore 2>/dev/null; then
      log_warning "$secrets_file is not in .gitignore"
      return 1
    fi
  fi

  log_success "Secrets file is properly ignored by git"
  return 0
}

# Check if secret is weak/default
secrets::is_weak() {
  local value="$1"

  # List of common weak passwords and default values
  local weak_patterns=(
    "password123"
    "admin123"
    "postgres"
    "hasura"
    "secret"
    "changeme"
    "dev-password"
    "admin-secret"
    "test"
    "demo"
    "password"
    "admin"
    "root"
    "123456"
    "qwerty"
  )

  # Convert to lowercase for comparison
  local value_lower
  value_lower=$(echo "$value" | tr '[:upper:]' '[:lower:]')

  for pattern in "${weak_patterns[@]}"; do
    if [[ "$value_lower" == *"$pattern"* ]]; then
      return 0  # Is weak
    fi
  done

  # Check length
  if [[ ${#value} -lt 16 ]]; then
    return 0  # Too short
  fi

  return 1  # Not weak
}

# Rotate all secrets
secrets::rotate_all() {
  local secrets_file="${1:-$SECRETS_FILE}"

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  log_info "Rotating all secrets in: $secrets_file"

  # Create backup
  cp "$secrets_file" "${secrets_file}.backup-$(date +%Y%m%d-%H%M%S)"

  # Extract all secret names
  local secret_names=()
  while IFS= read -r line; do
    if [[ "$line" =~ ^([A-Z_]+)= ]]; then
      secret_names+=("${BASH_REMATCH[1]}")
    fi
  done < "$secrets_file"

  # Rotate each secret
  local rotated=0
  for secret_name in "${secret_names[@]}"; do
    if secrets::rotate "$secret_name" "$secrets_file"; then
      rotated=$((rotated + 1))
    fi
  done

  log_success "Rotated $rotated secret(s)"
  log_warning "Remember to restart services to apply new secrets"

  return 0
}

# Encrypt secrets file (requires openssl or gpg)
secrets::encrypt() {
  local secrets_file="${1:-$SECRETS_FILE}"
  local output_file="${2:-${secrets_file}.enc}"
  local password="${3:-}"

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  if [[ -z "$password" ]]; then
    log_error "Password is required for encryption"
    return 1
  fi

  if command -v openssl >/dev/null 2>&1; then
    # Use AES-256-CBC encryption
    echo "$password" | openssl enc -aes-256-cbc -salt -pbkdf2 \
      -in "$secrets_file" -out "$output_file" -pass stdin

    log_success "Encrypted secrets to: $output_file"
    return 0
  else
    log_error "openssl not found - cannot encrypt"
    return 1
  fi
}

# Decrypt secrets file
secrets::decrypt() {
  local encrypted_file="${1:-${SECRETS_FILE}.enc}"
  local output_file="${2:-$SECRETS_FILE}"
  local password="${3:-}"

  if [[ ! -f "$encrypted_file" ]]; then
    log_error "Encrypted file not found: $encrypted_file"
    return 1
  fi

  if [[ -z "$password" ]]; then
    log_error "Password is required for decryption"
    return 1
  fi

  if command -v openssl >/dev/null 2>&1; then
    echo "$password" | openssl enc -aes-256-cbc -d -pbkdf2 \
      -in "$encrypted_file" -out "$output_file" -pass stdin

    chmod 600 "$output_file"
    log_success "Decrypted secrets to: $output_file"
    return 0
  else
    log_error "openssl not found - cannot decrypt"
    return 1
  fi
}

# Integration with HashiCorp Vault
secrets::import_from_vault() {
  local vault_path="${1:-secret/nself}"
  local secrets_file="${2:-$SECRETS_FILE}"

  if ! command -v vault >/dev/null 2>&1; then
    log_error "Vault CLI not installed"
    log_info "Install from: https://www.vaultproject.io/downloads"
    return 1
  fi

  log_info "Importing secrets from Vault: $vault_path"

  # Read from Vault and convert to .env format
  local vault_data
  vault_data=$(vault kv get -format=json "$vault_path" 2>/dev/null)

  if [[ $? -ne 0 ]]; then
    log_error "Failed to read from Vault"
    return 1
  fi

  # Parse JSON and write to secrets file
  if command -v jq >/dev/null 2>&1; then
    echo "$vault_data" | jq -r '.data.data | to_entries[] | "\(.key)=\(.value)"' > "$secrets_file"
    chmod 600 "$secrets_file"
    log_success "Imported secrets from Vault"
    return 0
  else
    log_error "jq not installed - cannot parse Vault response"
    return 1
  fi
}

# Export secrets to HashiCorp Vault
secrets::export_to_vault() {
  local secrets_file="${1:-$SECRETS_FILE}"
  local vault_path="${2:-secret/nself}"

  if ! command -v vault >/dev/null 2>&1; then
    log_error "Vault CLI not installed"
    return 1
  fi

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  log_info "Exporting secrets to Vault: $vault_path"

  # Build Vault command arguments
  local vault_args=""
  while IFS= read -r line; do
    if [[ "$line" =~ ^([A-Z_][A-Z0-9_]*)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"
      vault_args="$vault_args ${key}=${value}"
    fi
  done < "$secrets_file"

  # Write to Vault
  if vault kv put "$vault_path" $vault_args >/dev/null 2>&1; then
    log_success "Exported secrets to Vault"
    return 0
  else
    log_error "Failed to write to Vault"
    return 1
  fi
}

# Integration with AWS Secrets Manager
secrets::import_from_aws() {
  local secret_id="${1:-nself/secrets}"
  local secrets_file="${2:-$SECRETS_FILE}"

  if ! command -v aws >/dev/null 2>&1; then
    log_error "AWS CLI not installed"
    log_info "Install from: https://aws.amazon.com/cli/"
    return 1
  fi

  log_info "Importing secrets from AWS Secrets Manager: $secret_id"

  # Get secret value
  local secret_value
  secret_value=$(aws secretsmanager get-secret-value \
    --secret-id "$secret_id" \
    --query SecretString \
    --output text 2>/dev/null)

  if [[ $? -ne 0 ]]; then
    log_error "Failed to retrieve secret from AWS"
    return 1
  fi

  # Parse JSON and write to file
  if command -v jq >/dev/null 2>&1; then
    echo "$secret_value" | jq -r 'to_entries[] | "\(.key)=\(.value)"' > "$secrets_file"
    chmod 600 "$secrets_file"
    log_success "Imported secrets from AWS Secrets Manager"
    return 0
  else
    log_error "jq not installed - cannot parse AWS response"
    return 1
  fi
}

# Export secrets to AWS Secrets Manager
secrets::export_to_aws() {
  local secrets_file="${1:-$SECRETS_FILE}"
  local secret_id="${2:-nself/secrets}"

  if ! command -v aws >/dev/null 2>&1; then
    log_error "AWS CLI not installed"
    return 1
  fi

  if [[ ! -f "$secrets_file" ]]; then
    log_error "Secrets file not found: $secrets_file"
    return 1
  fi

  log_info "Exporting secrets to AWS Secrets Manager: $secret_id"

  # Convert .env to JSON
  local json_data="{"
  local first=true
  while IFS= read -r line; do
    if [[ "$line" =~ ^([A-Z_][A-Z0-9_]*)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      if [[ "$first" == "true" ]]; then
        first=false
      else
        json_data="${json_data},"
      fi

      json_data="${json_data}\"${key}\":\"${value}\""
    fi
  done < "$secrets_file"
  json_data="${json_data}}"

  # Create or update secret
  if aws secretsmanager describe-secret --secret-id "$secret_id" >/dev/null 2>&1; then
    # Update existing secret
    aws secretsmanager update-secret \
      --secret-id "$secret_id" \
      --secret-string "$json_data" >/dev/null 2>&1
  else
    # Create new secret
    aws secretsmanager create-secret \
      --name "$secret_id" \
      --secret-string "$json_data" >/dev/null 2>&1
  fi

  if [[ $? -eq 0 ]]; then
    log_success "Exported secrets to AWS Secrets Manager"
    return 0
  else
    log_error "Failed to export to AWS Secrets Manager"
    return 1
  fi
}

# Export functions
export -f secrets::generate_random
export -f secrets::generate_all
export -f secrets::rotate
export -f secrets::rotate_all
export -f secrets::validate
export -f secrets::show
export -f secrets::import_from_env
export -f secrets::export_to_env
export -f secrets::check_git
export -f secrets::is_weak
export -f secrets::encrypt
export -f secrets::decrypt
export -f secrets::import_from_vault
export -f secrets::export_to_vault
export -f secrets::import_from_aws
export -f secrets::export_to_aws
