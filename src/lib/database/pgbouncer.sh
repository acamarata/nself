#!/usr/bin/env bash
# pgbouncer.sh - PgBouncer auto-configuration
# Part of nself v0.9.8 - Production Features

set -euo pipefail

# Source utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../utils/env.sh" 2>/dev/null || true

# PgBouncer configuration
PGBOUNCER_VERSION="${PGBOUNCER_VERSION:-1.21.0}"
PGBOUNCER_PORT="${PGBOUNCER_PORT:-6432}"
PGBOUNCER_ADMIN_USER="${PGBOUNCER_ADMIN_USER:-pgbouncer}"
PGBOUNCER_ADMIN_PASSWORD="${PGBOUNCER_ADMIN_PASSWORD:-$(openssl rand -hex 16)}"

# =============================================================================
# AUTO-CONFIGURATION LOGIC
# =============================================================================

# Calculate optimal pool sizes based on services and expected load
calculate_pool_sizes() {
  load_env_with_priority 2>/dev/null || true

  # Count services that will connect to database
  local service_count=4 # Base: hasura, auth, postgres exporter, functions

  # Add optional services
  [[ "${FUNCTIONS_ENABLED:-false}" == "true" ]] && service_count=$((service_count + 1))
  [[ "${MLFLOW_ENABLED:-false}" == "true" ]] && service_count=$((service_count + 1))

  # Add custom services
  for i in {1..10}; do
    [[ -n "${!CS_${i}:-}" ]] && service_count=$((service_count + 1))
  done

  # Expected concurrent users (configurable)
  local expected_users="${EXPECTED_CONCURRENT_USERS:-100}"

  # Calculate pool sizes
  # Formula: (services * avg_connections_per_service) + (concurrent_users * connections_per_user)
  local min_pool_size=$((service_count * 2))
  local default_pool_size=$((service_count * 5 + expected_users / 10))
  local max_pool_size=$((service_count * 10 + expected_users / 5))

  # Ensure PostgreSQL can handle max connections
  local pg_max_connections=$((max_pool_size + 20)) # +20 for superuser/admin connections

  # Return as JSON
  printf '{"min_pool_size": %d, "default_pool_size": %d, "max_pool_size": %d, "pg_max_connections": %d, "service_count": %d, "expected_users": %d}\n' \
    "$min_pool_size" "$default_pool_size" "$max_pool_size" "$pg_max_connections" "$service_count" "$expected_users"
}

# Determine pool mode based on workload
determine_pool_mode() {
  local workload_type="${WORKLOAD_TYPE:-mixed}"

  case "$workload_type" in
    read-heavy | readonly)
      echo "transaction" # Best for short transactions
      ;;
    write-heavy | oltp)
      echo "session" # Better for long-running transactions
      ;;
    analytical | reporting)
      echo "session" # Need persistent connections
      ;;
    mixed | *)
      echo "transaction" # Good default for most apps
      ;;
  esac
}

# =============================================================================
# CONFIGURATION FILE GENERATION
# =============================================================================

# Generate pgbouncer.ini
generate_pgbouncer_ini() {
  local output_file="${1:-./pgbouncer/pgbouncer.ini}"
  local pools=$(calculate_pool_sizes)

  local min_pool=$(echo "$pools" | grep -o '"min_pool_size": *[0-9]*' | sed 's/"min_pool_size": *//')
  local default_pool=$(echo "$pools" | grep -o '"default_pool_size": *[0-9]*' | sed 's/"default_pool_size": *//')
  local max_pool=$(echo "$pools" | grep -o '"max_pool_size": *[0-9]*' | sed 's/"max_pool_size": *//')

  local pool_mode=$(determine_pool_mode)

  load_env_with_priority 2>/dev/null || true
  local db_name="${POSTGRES_DB:-nself}"
  local db_user="${POSTGRES_USER:-postgres}"
  local db_host="${POSTGRES_HOST:-postgres}"

  mkdir -p "$(dirname "$output_file")"

  cat >"$output_file" <<EOF
;; PgBouncer configuration - Auto-generated by nself
;; Generated: $(date)

[databases]
$db_name = host=$db_host port=5432 dbname=$db_name
postgres = host=$db_host port=5432 dbname=postgres

[pgbouncer]
;; Connection pooling
pool_mode = $pool_mode
max_client_conn = $max_pool
default_pool_size = $default_pool
min_pool_size = $min_pool
reserve_pool_size = $((default_pool / 2))
reserve_pool_timeout = 5

;; Timeouts
server_idle_timeout = 600
server_lifetime = 3600
server_connect_timeout = 15
query_timeout = 0
query_wait_timeout = 120
client_idle_timeout = 0
idle_transaction_timeout = 0

;; Authentication
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt

;; Logging
admin_users = $PGBOUNCER_ADMIN_USER
stats_users = $PGBOUNCER_ADMIN_USER

;; Connection settings
listen_addr = 0.0.0.0
listen_port = $PGBOUNCER_PORT

;; Console access
unix_socket_dir = /tmp

;; Performance tuning
max_db_connections = 0
max_user_connections = 0
server_reset_query = DISCARD ALL
server_check_query = SELECT 1
server_check_delay = 30

;; Logging
log_connections = 1
log_disconnections = 1
log_pooler_errors = 1
stats_period = 60

;; Dangerous settings (tuned for safety)
ignore_startup_parameters = extra_float_digits

;; Pkt buffer
pkt_buf = 4096
listen_backlog = 128
sbuf_loopcnt = 5
EOF

  echo "$output_file"
}

# Generate userlist.txt for authentication
generate_userlist() {
  local output_file="${1:-./pgbouncer/userlist.txt}"
  load_env_with_priority 2>/dev/null || true

  local db_user="${POSTGRES_USER:-postgres}"
  local db_password="${POSTGRES_PASSWORD:-postgres}"

  # Generate MD5 hash for password
  # Format: "md5" + md5(password + username)
  local password_hash="md5$(echo -n "${db_password}${db_user}" | md5sum | cut -d' ' -f1 2>/dev/null || echo -n "${db_password}${db_user}" | md5)"

  mkdir -p "$(dirname "$output_file")"

  cat >"$output_file" <<EOF
;; PgBouncer user list - Auto-generated by nself
;; Format: "username" "password" or "username" "md5hash"

"$db_user" "$password_hash"
"$PGBOUNCER_ADMIN_USER" "md5$(echo -n "${PGBOUNCER_ADMIN_PASSWORD}${PGBOUNCER_ADMIN_USER}" | md5sum | cut -d' ' -f1 2>/dev/null || echo -n "${PGBOUNCER_ADMIN_PASSWORD}${PGBOUNCER_ADMIN_USER}" | md5)"
EOF

  chmod 600 "$output_file"
  echo "$output_file"
}

# Generate Docker Compose service for PgBouncer
generate_docker_compose_service() {
  load_env_with_priority 2>/dev/null || true
  local project_name="${PROJECT_NAME:-nself}"

  cat <<EOF

  # PgBouncer - Connection Pooler
  pgbouncer:
    image: pgbouncer/pgbouncer:${PGBOUNCER_VERSION}
    container_name: \${PROJECT_NAME}_pgbouncer
    restart: unless-stopped
    environment:
      DATABASES_HOST: postgres
      DATABASES_PORT: 5432
      DATABASES_USER: \${POSTGRES_USER:-postgres}
      DATABASES_PASSWORD: \${POSTGRES_PASSWORD:-postgres}
      DATABASES_DBNAME: \${POSTGRES_DB:-nself}
      PGBOUNCER_POOL_MODE: ${PGBOUNCER_POOL_MODE:-transaction}
      PGBOUNCER_MAX_CLIENT_CONN: ${PGBOUNCER_MAX_CLIENT_CONN:-200}
      PGBOUNCER_DEFAULT_POOL_SIZE: ${PGBOUNCER_DEFAULT_POOL_SIZE:-25}
    ports:
      - "\${PGBOUNCER_PORT:-6432}:6432"
    volumes:
      - ./pgbouncer/pgbouncer.ini:/etc/pgbouncer/pgbouncer.ini:ro
      - ./pgbouncer/userlist.txt:/etc/pgbouncer/userlist.txt:ro
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - nself_network
    healthcheck:
      test: ["CMD", "pg_isready", "-h", "localhost", "-p", "6432"]
      interval: 10s
      timeout: 5s
      retries: 5
EOF
}

# =============================================================================
# SETUP & INSTALLATION
# =============================================================================

# Setup PgBouncer (generate configs and update environment)
setup_pgbouncer() {
  echo "Setting up PgBouncer..."

  # Generate configuration files
  local ini_file=$(generate_pgbouncer_ini)
  echo "Generated: $ini_file"

  local userlist_file=$(generate_userlist)
  echo "Generated: $userlist_file"

  # Show calculated pool sizes
  echo ""
  echo "Calculated Pool Sizes:"
  calculate_pool_sizes | jq '.' 2>/dev/null || calculate_pool_sizes

  echo ""
  echo "Pool Mode: $(determine_pool_mode)"

  echo ""
  echo "PgBouncer setup complete!"
  echo ""
  echo "Next steps:"
  echo "1. Add the PgBouncer service to docker-compose.yml (or rebuild with PGBOUNCER_ENABLED=true)"
  echo "2. Update your application connection strings to use port $PGBOUNCER_PORT"
  echo "3. Run: docker compose up -d pgbouncer"
  echo ""
  echo "Connection string format:"
  echo "  postgres://\${POSTGRES_USER}:\${POSTGRES_PASSWORD}@pgbouncer:6432/\${POSTGRES_DB}"
}

# Update .env file to enable PgBouncer
enable_pgbouncer() {
  if ! grep -q "PGBOUNCER_ENABLED" .env 2>/dev/null; then
    echo "" >>.env
    echo "# PgBouncer Configuration" >>.env
    echo "PGBOUNCER_ENABLED=true" >>.env
    echo "PGBOUNCER_PORT=6432" >>.env
    echo "PGBOUNCER_ADMIN_USER=$PGBOUNCER_ADMIN_USER" >>.env
    echo "PGBOUNCER_ADMIN_PASSWORD=$PGBOUNCER_ADMIN_PASSWORD" >>.env
    echo "Added PgBouncer configuration to .env"
  else
    sed -i.bak 's/PGBOUNCER_ENABLED=.*/PGBOUNCER_ENABLED=true/' .env
    echo "Enabled PgBouncer in .env"
  fi
}

# =============================================================================
# MONITORING & STATS
# =============================================================================

# Show PgBouncer statistics
show_stats() {
  load_env_with_priority 2>/dev/null || true
  local project_name="${PROJECT_NAME:-nself}"

  if ! docker ps --format "{{.Names}}" | grep -q "${project_name}_pgbouncer"; then
    echo "PgBouncer is not running"
    return 1
  fi

  echo "PgBouncer Statistics:"
  echo ""

  # Show pools
  docker exec -it "${project_name}_pgbouncer" psql -h localhost -p 6432 -U "$PGBOUNCER_ADMIN_USER" pgbouncer \
    -c "SHOW POOLS;" 2>/dev/null || echo "Unable to retrieve pool stats"

  echo ""

  # Show databases
  docker exec -it "${project_name}_pgbouncer" psql -h localhost -p 6432 -U "$PGBOUNCER_ADMIN_USER" pgbouncer \
    -c "SHOW DATABASES;" 2>/dev/null || echo "Unable to retrieve database stats"

  echo ""

  # Show stats
  docker exec -it "${project_name}_pgbouncer" psql -h localhost -p 6432 -U "$PGBOUNCER_ADMIN_USER" pgbouncer \
    -c "SHOW STATS;" 2>/dev/null || echo "Unable to retrieve stats"
}

# =============================================================================
# EXPORTS
# =============================================================================

export -f calculate_pool_sizes determine_pool_mode
export -f generate_pgbouncer_ini generate_userlist generate_docker_compose_service
export -f setup_pgbouncer enable_pgbouncer show_stats

# If run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  case "${1:-help}" in
    setup)
      setup_pgbouncer
      ;;
    enable)
      enable_pgbouncer
      ;;
    calculate)
      calculate_pool_sizes | jq '.' 2>/dev/null || calculate_pool_sizes
      ;;
    generate-ini)
      generate_pgbouncer_ini "${2:-./pgbouncer/pgbouncer.ini}"
      ;;
    generate-userlist)
      generate_userlist "${2:-./pgbouncer/userlist.txt}"
      ;;
    stats)
      show_stats
      ;;
    docker-compose)
      generate_docker_compose_service
      ;;
    *)
      echo "Usage: $0 {setup|enable|calculate|generate-ini|generate-userlist|stats|docker-compose}"
      echo ""
      echo "Commands:"
      echo "  setup                 Complete PgBouncer setup (generate configs)"
      echo "  enable                Enable PgBouncer in .env"
      echo "  calculate             Calculate optimal pool sizes"
      echo "  generate-ini [file]   Generate pgbouncer.ini"
      echo "  generate-userlist     Generate userlist.txt"
      echo "  stats                 Show PgBouncer statistics"
      echo "  docker-compose        Generate Docker Compose service definition"
      exit 1
      ;;
  esac
fi
