// {{SERVICE_NAME}} Service - Rust
// Auto-generated by nself

use actix_web::{web, App, HttpResponse, HttpServer, Result};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use std::env;

const SERVICE_NAME: &str = "{{SERVICE_NAME}}";
const VERSION: &str = "1.0.0";

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    service: String,
    timestamp: String,
}

#[derive(Serialize)]
struct ServiceResponse {
    service: String,
    version: String,
    message: String,
}

#[derive(Serialize)]
struct DataResponse {
    example: String,
    timestamp: String,
}

async fn health() -> Result<HttpResponse> {
    let response = HealthResponse {
        status: "healthy".to_string(),
        service: SERVICE_NAME.to_string(),
        timestamp: Utc::now().to_rfc3339(),
    };
    Ok(HttpResponse::Ok().json(response))
}

async fn index() -> Result<HttpResponse> {
    let response = ServiceResponse {
        service: SERVICE_NAME.to_string(),
        version: VERSION.to_string(),
        message: "Service is running".to_string(),
    };
    Ok(HttpResponse::Ok().json(response))
}

async fn get_data() -> Result<HttpResponse> {
    // Add your business logic here
    let response = DataResponse {
        example: "data".to_string(),
        timestamp: Utc::now().to_rfc3339(),
    };
    Ok(HttpResponse::Ok().json(response))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let port = env::var("PORT").unwrap_or_else(|_| "{{SERVICE_PORT}}".to_string());
    let bind_addr = format!("0.0.0.0:{}", port);
    
    println!("{} service starting on port {}", SERVICE_NAME, port);
    
    HttpServer::new(|| {
        App::new()
            .route("/health", web::get().to(health))
            .route("/", web::get().to(index))
            .route("/api/data", web::get().to(get_data))
    })
    .bind(&bind_addr)?
    .run()
    .await
}