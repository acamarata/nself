#!/usr/bin/env bash
# generate-computed-env.sh - Generate computed environment variables
# This creates .env.computed with all derived variables that docker-compose.yml references

generate_computed_env() {
  local output_file="${1:-.env.computed}"

  # Read current environment to get base values
  local project_name="${PROJECT_NAME:-myproject}"
  local env="${ENV:-dev}"
  local base_domain="${BASE_DOMAIN:-localhost}"

  # Compute derived variables
  local docker_network="${project_name}_network"
  local postgres_user="${POSTGRES_USER:-postgres}"
  local postgres_password="${POSTGRES_PASSWORD:-}"
  local postgres_db="${POSTGRES_DB:-${project_name}}"
  local hasura_admin_secret="${HASURA_GRAPHQL_ADMIN_SECRET:-}"
  local hasura_jwt_secret="${HASURA_GRAPHQL_JWT_SECRET:-${HASURA_JWT_SECRET:-}}"

  # Construct DATABASE_URL
  # Bug #27 fix: Add sslmode parameter based on environment
  local sslmode_param=""
  if [[ "$env" == "dev" || "$env" == "development" || "$env" == "local" ]]; then
    sslmode_param="?sslmode=disable"
  elif [[ "$env" == "prod" || "$env" == "production" ]]; then
    sslmode_param="?sslmode=require"
  fi
  local database_url="postgresql://${postgres_user}:${postgres_password}@postgres:5432/${postgres_db}${sslmode_param}"

  # Construct HASURA_GRAPHQL_JWT_SECRET (if needed)
  # Bug #25 fix: If the value is already valid JSON (starts with '{'), pass it through unchanged.
  # Only wrap in JSON if it's a raw key string.
  local hasura_jwt_config=""
  if [[ -n "$hasura_jwt_secret" ]]; then
    if [[ "$hasura_jwt_secret" == "{"* ]]; then
      # Already JSON — use as-is (don't double-wrap)
      hasura_jwt_config="$hasura_jwt_secret"
    else
      # Raw key string — wrap in JSON
      hasura_jwt_config="{\"type\":\"HS256\",\"key\":\"${hasura_jwt_secret}\"}"
    fi
  fi

  # Construct HASURA_GRAPHQL_CORS_DOMAIN
  # Bug #26 fix: No spaces after commas — Hasura parses empty domain strings otherwise
  local cors_domain="https://*.${base_domain},http://*.${base_domain},http://localhost:*"
  if [[ "$env" == "dev" || "$env" == "development" ]]; then
    cors_domain="${cors_domain},http://localhost:3000,http://localhost:3001,http://localhost:8080"
  fi

  # Write computed variables to file
  cat > "$output_file" <<EOF
# Generated by nself build - DO NOT EDIT
# Computed environment variables for docker-compose.yml
# These are derived from your base configuration in .env

# Docker Network
DOCKER_NETWORK=${docker_network}

# Database URLs
DATABASE_URL=${database_url}
POSTGRES_URL=${database_url}
AUTH_DATABASE_URL=${database_url}
STORAGE_DATABASE_URL=${database_url}

# Hasura Configuration
EOF

  # Add JWT config if available
  # Bug #25 fix (round 5): Single-quote JSON values so they survive bash `source`.
  # Without single quotes, `source .env.computed` strips inner double quotes from JSON,
  # turning {"type":"HS256"} into {type:HS256} which Hasura can't parse.
  if [[ -n "$hasura_jwt_config" ]]; then
    if [[ "$hasura_jwt_config" == "{"* ]]; then
      # JSON value — must be single-quoted to preserve double quotes during source
      printf "HASURA_GRAPHQL_JWT_SECRET='%s'\n" "$hasura_jwt_config" >> "$output_file"
    else
      printf "HASURA_GRAPHQL_JWT_SECRET=%s\n" "$hasura_jwt_config" >> "$output_file"
    fi
  fi

  # Add CORS domain
  printf "HASURA_GRAPHQL_CORS_DOMAIN=%s\n" "$cors_domain" >> "$output_file"

  # Add footer
  cat >> "$output_file" <<EOF

# Usage: These variables are automatically loaded by nself CLI commands
# For direct docker-compose usage, load with:
#   docker-compose --env-file .env --env-file .env.computed up
EOF
}

# Export function for use in other scripts
export -f generate_computed_env
