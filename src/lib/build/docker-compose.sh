#!/usr/bin/env bash
# docker-compose.sh - Docker Compose generation for build

# Generate docker-compose.yml
generate_docker_compose() {
  local force="${1:-false}"

  # Check if docker-compose.yml already exists
  if [[ "$force" != "true" ]] && [[ -f "docker-compose.yml" ]]; then
    show_info "docker-compose.yml already exists (use --force to regenerate)"
    return 0
  fi

  # Start generating docker-compose.yml
  local compose_file="docker-compose.yml"
  local temp_file=$(mktemp)

  # Write header
  cat > "$temp_file" <<EOF
# Generated by nself build - $(date)
# Project: ${PROJECT_NAME}
# Environment: ${ENV:-dev}

services:
EOF

  # Generate network configuration
  local networks_added=false

  # Add services based on what's enabled
  if [[ "${NGINX_ENABLED:-true}" == "true" ]]; then
    add_nginx_service "$temp_file"
    networks_added=true
  fi

  if [[ "${POSTGRES_ENABLED:-true}" == "true" ]]; then
    add_postgres_service "$temp_file"
    networks_added=true
  fi

  if [[ "${REDIS_ENABLED:-false}" == "true" ]]; then
    add_redis_service "$temp_file"
    networks_added=true
  fi

  if [[ "${HASURA_ENABLED:-false}" == "true" ]]; then
    add_hasura_service "$temp_file"
    networks_added=true
  fi

  if [[ "${AUTH_ENABLED:-false}" == "true" ]]; then
    add_auth_service "$temp_file"
    networks_added=true
  fi

  if [[ "${STORAGE_ENABLED:-false}" == "true" ]]; then
    add_storage_service "$temp_file"
    networks_added=true
  fi

  # Add custom services
  add_custom_services "$temp_file"

  # Add volumes section
  add_volumes_section "$temp_file"

  # Add networks section if services were added
  if [[ "$networks_added" == true ]]; then
    add_networks_section "$temp_file"
  fi

  # Move temp file to final location
  mv "$temp_file" "$compose_file"

  return 0
}

# Add nginx service
add_nginx_service() {
  local file="$1"

  cat >> "$file" <<EOF

  nginx:
    image: nginx:alpine
    container_name: \${PROJECT_NAME}_nginx
    restart: unless-stopped
    ports:
      - "\${NGINX_PORT:-80}:80"
      - "\${NGINX_SSL_PORT:-443}:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./nginx/routes:/etc/nginx/routes:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - nginx_cache:/var/cache/nginx
    networks:
      - nself_network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
EOF

  # Add dependencies if other services exist
  local deps=()
  [[ "${HASURA_ENABLED:-false}" == "true" ]] && deps+=("hasura")
  [[ "${AUTH_ENABLED:-false}" == "true" ]] && deps+=("auth")
  [[ "${STORAGE_ENABLED:-false}" == "true" ]] && deps+=("storage")

  if [[ ${#deps[@]} -gt 0 ]]; then
    echo "    depends_on:" >> "$file"
    for dep in "${deps[@]}"; do
      echo "      - $dep" >> "$file"
    done
  fi
}

# Add PostgreSQL service
add_postgres_service() {
  local file="$1"

  cat >> "$file" <<EOF

  postgres:
    image: postgres:\${POSTGRES_VERSION:-15}-alpine
    container_name: \${PROJECT_NAME}_postgres
    restart: unless-stopped
    ports:
      - "\${POSTGRES_PORT:-5432}:5432"
    environment:
      POSTGRES_DB: \${POSTGRES_DB:-\${PROJECT_NAME}_db}
      POSTGRES_USER: \${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: \${POSTGRES_PASSWORD:-postgres}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - nself_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U \${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
EOF
}

# Add Redis service
add_redis_service() {
  local file="$1"

  cat >> "$file" <<EOF

  redis:
    image: redis:\${REDIS_VERSION:-7}-alpine
    container_name: \${PROJECT_NAME}_redis
    restart: unless-stopped
    ports:
      - "\${REDIS_PORT:-6379}:6379"
    volumes:
      - redis_data:/data
    networks:
      - nself_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
EOF

  # Add Redis password if configured
  if [[ -n "${REDIS_PASSWORD:-}" ]]; then
    sed -i.bak '/container_name:.*_redis/a\    command: redis-server --requirepass ${REDIS_PASSWORD}' "$file"
    rm -f "${file}.bak"
  fi
}

# Add Hasura service
add_hasura_service() {
  local file="$1"

  cat >> "$file" <<EOF

  hasura:
    image: hasura/graphql-engine:\${HASURA_VERSION:-latest}
    container_name: \${PROJECT_NAME}_hasura
    restart: unless-stopped
    ports:
      - "\${HASURA_PORT:-8080}:8080"
    environment:
      HASURA_GRAPHQL_DATABASE_URL: postgres://\${POSTGRES_USER:-postgres}:\${POSTGRES_PASSWORD:-postgres}@postgres:5432/\${POSTGRES_DB:-\${PROJECT_NAME}_db}
      HASURA_GRAPHQL_ENABLE_CONSOLE: "\${HASURA_CONSOLE:-true}"
      HASURA_GRAPHQL_DEV_MODE: "\${HASURA_DEV_MODE:-true}"
      HASURA_GRAPHQL_ADMIN_SECRET: \${HASURA_ADMIN_SECRET:-myadminsecret}
      HASURA_GRAPHQL_JWT_SECRET: \${HASURA_JWT_SECRET:-}
      HASURA_GRAPHQL_UNAUTHORIZED_ROLE: \${HASURA_UNAUTHORIZED_ROLE:-anonymous}
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - nself_network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3
EOF
}

# Add Auth service
add_auth_service() {
  local file="$1"

  cat >> "$file" <<EOF

  auth:
    image: nhost/hasura-auth:\${AUTH_VERSION:-latest}
    container_name: \${PROJECT_NAME}_auth
    restart: unless-stopped
    ports:
      - "\${AUTH_PORT:-4000}:4000"
    environment:
      DATABASE_URL: postgres://\${POSTGRES_USER:-postgres}:\${POSTGRES_PASSWORD:-postgres}@postgres:5432/\${POSTGRES_DB:-\${PROJECT_NAME}_db}
      HASURA_GRAPHQL_ADMIN_SECRET: \${HASURA_ADMIN_SECRET:-myadminsecret}
      HASURA_GRAPHQL_URL: http://hasura:8080/v1/graphql
      JWT_SECRET: \${AUTH_JWT_SECRET:-\${HASURA_JWT_SECRET:-}}
      AUTH_HOST: \${AUTH_HOST:-0.0.0.0}
      AUTH_PORT: 4000
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - nself_network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:4000/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3
EOF
}

# Add Storage service
add_storage_service() {
  local file="$1"

  cat >> "$file" <<EOF

  storage:
    image: nhost/hasura-storage:\${STORAGE_VERSION:-latest}
    container_name: \${PROJECT_NAME}_storage
    restart: unless-stopped
    ports:
      - "\${STORAGE_PORT:-5000}:5000"
    environment:
      DATABASE_URL: postgres://\${POSTGRES_USER:-postgres}:\${POSTGRES_PASSWORD:-postgres}@postgres:5432/\${POSTGRES_DB:-\${PROJECT_NAME}_db}
      HASURA_METADATA: "1"
      HASURA_GRAPHQL_URL: http://hasura:8080/v1
      HASURA_GRAPHQL_ADMIN_SECRET: \${HASURA_ADMIN_SECRET:-myadminsecret}
      S3_ENDPOINT: \${S3_ENDPOINT:-}
      S3_ACCESS_KEY: \${S3_ACCESS_KEY:-}
      S3_SECRET_KEY: \${S3_SECRET_KEY:-}
      S3_BUCKET: \${S3_BUCKET:-\${PROJECT_NAME}-storage}
      S3_REGION: \${S3_REGION:-us-east-1}
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - storage_data:/data
    networks:
      - nself_network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:5000/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3
EOF
}

# Add custom services
add_custom_services() {
  local file="$1"

  # Check for custom service definitions
  if [[ -d "services" ]]; then
    for service_file in services/*.yml services/*.yaml; do
      if [[ -f "$service_file" ]]; then
        echo "" >> "$file"
        cat "$service_file" >> "$file"
      fi
    done
  fi
}

# Add volumes section
add_volumes_section() {
  local file="$1"

  echo "" >> "$file"
  echo "volumes:" >> "$file"

  [[ "${POSTGRES_ENABLED:-true}" == "true" ]] && echo "  postgres_data:" >> "$file"
  [[ "${REDIS_ENABLED:-false}" == "true" ]] && echo "  redis_data:" >> "$file"
  [[ "${STORAGE_ENABLED:-false}" == "true" ]] && echo "  storage_data:" >> "$file"
  [[ "${NGINX_ENABLED:-true}" == "true" ]] && echo "  nginx_cache:" >> "$file"
}

# Add networks section
add_networks_section() {
  local file="$1"

  cat >> "$file" <<EOF

networks:
  nself_network:
    driver: bridge
    name: \${PROJECT_NAME}_network
EOF
}

# Validate docker-compose.yml
validate_docker_compose() {
  local compose_file="${1:-docker-compose.yml}"

  if [[ ! -f "$compose_file" ]]; then
    show_error "docker-compose.yml not found"
    return 1
  fi

  # Try to validate the compose file
  if command_exists docker-compose; then
    if docker-compose -f "$compose_file" config >/dev/null 2>&1; then
      return 0
    else
      show_error "docker-compose.yml validation failed"
      return 1
    fi
  elif docker compose version >/dev/null 2>&1; then
    if docker compose -f "$compose_file" config >/dev/null 2>&1; then
      return 0
    else
      show_error "docker-compose.yml validation failed"
      return 1
    fi
  fi

  return 0
}

# Export functions
export -f generate_docker_compose
export -f add_nginx_service
export -f add_postgres_service
export -f add_redis_service
export -f add_hasura_service
export -f add_auth_service
export -f add_storage_service
export -f add_custom_services
export -f add_volumes_section
export -f add_networks_section
export -f validate_docker_compose