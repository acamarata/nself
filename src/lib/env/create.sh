#!/usr/bin/env bash

# create.sh - Environment creation functionality
# POSIX-compliant, no Bash 4+ features

# Get the directory where this script is located
ENV_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_ROOT="$(dirname "$ENV_LIB_DIR")"

# Source dependencies
source "$LIB_ROOT/utils/display.sh" 2>/dev/null || true
source "$LIB_ROOT/utils/platform-compat.sh" 2>/dev/null || true

# Environment directory
ENVIRONMENTS_DIR="${ENVIRONMENTS_DIR:-./.environments}"

# Initialize environments directory
env::init_directory() {
  if [[ ! -d "$ENVIRONMENTS_DIR" ]]; then
    mkdir -p "$ENVIRONMENTS_DIR"
    log_info "Created environments directory: $ENVIRONMENTS_DIR"
  fi
}

# Create a new environment from template
env::create() {
  local env_name="$1"
  local template="${2:-local}"
  local force="${3:-false}"

  # Validate environment name
  if [[ -z "$env_name" ]]; then
    log_error "Environment name is required"
    return 1
  fi

  # Sanitize environment name (lowercase, alphanumeric and hyphens only)
  local safe_name
  safe_name=$(printf "%s" "$env_name" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-')

  if [[ "$safe_name" != "$env_name" ]]; then
    log_warning "Environment name sanitized to: $safe_name"
  fi

  # Check for reserved names
  case "$safe_name" in
    dev | development | local | staging | stage | prod | production)
      # These are allowed standard names
      ;;
    *)
      # Custom names are fine
      ;;
  esac

  # Initialize directory
  env::init_directory

  local env_dir="$ENVIRONMENTS_DIR/$safe_name"

  # Check if environment already exists
  if [[ -d "$env_dir" ]] && [[ "$force" != "true" ]]; then
    log_error "Environment '$safe_name' already exists"
    log_info "Use --force to overwrite"
    return 1
  fi

  # Create environment directory
  mkdir -p "$env_dir"

  # Generate environment configuration based on template
  case "$template" in
    local | dev | development)
      env::create_local_env "$env_dir" "$safe_name"
      ;;
    staging | stage)
      env::create_staging_env "$env_dir" "$safe_name"
      ;;
    prod | production)
      env::create_prod_env "$env_dir" "$safe_name"
      ;;
    *)
      # Use template as base if it's a path to another environment
      if [[ -d "$ENVIRONMENTS_DIR/$template" ]]; then
        env::create_from_template "$env_dir" "$safe_name" "$template"
      else
        log_error "Unknown template: $template"
        log_info "Available templates: local, staging, prod"
        return 1
      fi
      ;;
  esac

  log_success "Created environment: $safe_name"
  return 0
}

# Create local development environment
env::create_local_env() {
  local env_dir="$1"
  local env_name="$2"

  cat >"$env_dir/.env" <<EOF
# ${env_name} Environment Configuration
# Generated by nself on $(date +%Y-%m-%d)

# Environment Settings
ENV=development
DEBUG=true
LOG_LEVEL=debug

# Domain Configuration
BASE_DOMAIN=localhost

# SSL Configuration
SSL_ENABLED=true
SSL_PROVIDER=self-signed

# Core Services (always enabled)
# POSTGRES_ENABLED=true
# HASURA_ENABLED=true
# AUTH_ENABLED=true
# NGINX_ENABLED=true

# Optional Services (uncomment to enable)
# REDIS_ENABLED=true
# MINIO_ENABLED=true
# MEILISEARCH_ENABLED=true
# MAILPIT_ENABLED=true
# FUNCTIONS_ENABLED=true
# MLFLOW_ENABLED=true
# NSELF_ADMIN_ENABLED=true

# Monitoring (enables full bundle)
# MONITORING_ENABLED=true

# Database Configuration
POSTGRES_DB=\${PROJECT_NAME:-myproject}
POSTGRES_USER=postgres
POSTGRES_PASSWORD=development-password

# Security (use secure values in production)
HASURA_GRAPHQL_ADMIN_SECRET=hasura-admin-secret
JWT_SECRET=jwt-secret-for-development-only
EOF

  # Create server.json for this environment
  cat >"$env_dir/server.json" <<EOF
{
  "name": "${env_name}",
  "type": "local",
  "host": "localhost",
  "description": "Local development environment"
}
EOF

  log_info "Created local development environment"
}

# Create staging environment
env::create_staging_env() {
  local env_dir="$1"
  local env_name="$2"

  cat >"$env_dir/.env" <<EOF
# ${env_name} Staging Environment Configuration
# Generated by nself on $(date +%Y-%m-%d)

# Environment Settings
ENV=staging
DEBUG=false
LOG_LEVEL=info

# Domain Configuration (update with your staging domain)
BASE_DOMAIN=staging.example.com

# SSL Configuration
SSL_ENABLED=true
SSL_PROVIDER=letsencrypt
SSL_EMAIL=admin@example.com

# Core Services
POSTGRES_ENABLED=true
HASURA_ENABLED=true
AUTH_ENABLED=true
NGINX_ENABLED=true

# Optional Services
REDIS_ENABLED=true
MINIO_ENABLED=true
MAILPIT_ENABLED=true

# Monitoring (recommended for staging)
MONITORING_ENABLED=true

# Database Configuration
POSTGRES_DB=\${PROJECT_NAME:-myproject}_staging
POSTGRES_USER=postgres
# POSTGRES_PASSWORD should be in .env.secrets

# Security (set in .env.secrets)
# HASURA_GRAPHQL_ADMIN_SECRET=
# JWT_SECRET=
EOF

  # Create server.json for this environment
  cat >"$env_dir/server.json" <<EOF
{
  "name": "${env_name}",
  "type": "staging",
  "host": "",
  "port": 22,
  "user": "",
  "key": "",
  "description": "Staging environment - configure SSH settings"
}
EOF

  # Create empty secrets file
  cat >"$env_dir/.env.secrets" <<EOF
# ${env_name} Secrets - DO NOT COMMIT TO VERSION CONTROL
# Generated by nself on $(date +%Y-%m-%d)

# Database
POSTGRES_PASSWORD=

# Security Secrets
HASURA_GRAPHQL_ADMIN_SECRET=
JWT_SECRET=
COOKIE_SECRET=

# Service API Keys
# MINIO_ROOT_PASSWORD=
# REDIS_PASSWORD=
EOF

  chmod 600 "$env_dir/.env.secrets"

  log_info "Created staging environment"
  log_warning "Remember to configure server.json with your staging server details"
}

# Create production environment
env::create_prod_env() {
  local env_dir="$1"
  local env_name="$2"

  cat >"$env_dir/.env" <<EOF
# ${env_name} Production Environment Configuration
# Generated by nself on $(date +%Y-%m-%d)

# Environment Settings
ENV=production
DEBUG=false
LOG_LEVEL=warning

# Domain Configuration (update with your production domain)
BASE_DOMAIN=example.com

# SSL Configuration
SSL_ENABLED=true
SSL_PROVIDER=letsencrypt
SSL_EMAIL=admin@example.com

# Core Services
POSTGRES_ENABLED=true
HASURA_ENABLED=true
AUTH_ENABLED=true
NGINX_ENABLED=true

# Optional Services
REDIS_ENABLED=true
MINIO_ENABLED=true

# Monitoring (required for production)
MONITORING_ENABLED=true

# Database Configuration
POSTGRES_DB=\${PROJECT_NAME:-myproject}
POSTGRES_USER=postgres
# POSTGRES_PASSWORD should be in .env.secrets

# Performance Settings
HASURA_GRAPHQL_DEV_MODE=false
HASURA_GRAPHQL_ENABLE_CONSOLE=false

# Security (set in .env.secrets)
# HASURA_GRAPHQL_ADMIN_SECRET=
# JWT_SECRET=
EOF

  # Create server.json for this environment
  cat >"$env_dir/server.json" <<EOF
{
  "name": "${env_name}",
  "type": "production",
  "host": "",
  "port": 22,
  "user": "",
  "key": "",
  "description": "Production environment - configure SSH settings"
}
EOF

  # Create empty secrets file
  cat >"$env_dir/.env.secrets" <<EOF
# ${env_name} Production Secrets - DO NOT COMMIT TO VERSION CONTROL
# Generated by nself on $(date +%Y-%m-%d)

# Database (use strong password)
POSTGRES_PASSWORD=

# Security Secrets (generate with: openssl rand -hex 32)
HASURA_GRAPHQL_ADMIN_SECRET=
JWT_SECRET=
COOKIE_SECRET=

# Service API Keys
MINIO_ROOT_PASSWORD=
REDIS_PASSWORD=
EOF

  chmod 600 "$env_dir/.env.secrets"

  log_info "Created production environment"
  log_warning "Remember to configure server.json with your production server details"
  log_warning "Generate secure secrets with: nself prod secrets generate"
}

# Create environment from existing template
env::create_from_template() {
  local env_dir="$1"
  local env_name="$2"
  local template_name="$3"

  local template_dir="$ENVIRONMENTS_DIR/$template_name"

  # Copy all files from template
  cp -r "$template_dir/"* "$env_dir/" 2>/dev/null || true

  # Update environment name in .env
  if [[ -f "$env_dir/.env" ]]; then
    safe_sed_inline "$env_dir/.env" "s/^# ${template_name}/# ${env_name}/g"
  fi

  # Update server.json
  if [[ -f "$env_dir/server.json" ]]; then
    safe_sed_inline "$env_dir/server.json" "s/\"name\": \"${template_name}\"/\"name\": \"${env_name}\"/g"
  fi

  log_info "Created environment from template: $template_name"
}

# List all environments
env::list() {
  env::init_directory

  local current
  current=$(env::get_current 2>/dev/null || echo "")

  printf "Available environments:\n"

  for env_dir in "$ENVIRONMENTS_DIR"/*/; do
    if [[ -d "$env_dir" ]]; then
      local env_name
      env_name=$(basename "$env_dir")

      if [[ "$env_name" == "$current" ]]; then
        printf "  ${COLOR_GREEN}*${COLOR_RESET} %s (current)\n" "$env_name"
      else
        printf "    %s\n" "$env_name"
      fi
    fi
  done

  if [[ ! -d "$ENVIRONMENTS_DIR" ]] || [[ -z "$(ls -A "$ENVIRONMENTS_DIR" 2>/dev/null)" ]]; then
    printf "  ${COLOR_YELLOW}No environments found${COLOR_RESET}\n"
    printf "\n  Create one with: nself env create <name>\n"
  fi
}

# Get current environment name
env::get_current() {
  local current_file=".current-env"

  if [[ -f "$current_file" ]]; then
    cat "$current_file"
  else
    # Default to local/dev
    echo "local"
  fi
}

# Delete an environment
env::delete() {
  local env_name="$1"
  local force="${2:-false}"

  if [[ -z "$env_name" ]]; then
    log_error "Environment name is required"
    return 1
  fi

  local env_dir="$ENVIRONMENTS_DIR/$env_name"

  if [[ ! -d "$env_dir" ]]; then
    log_error "Environment '$env_name' does not exist"
    return 1
  fi

  # Check if it's the current environment
  local current
  current=$(env::get_current 2>/dev/null || echo "")

  if [[ "$env_name" == "$current" ]]; then
    log_error "Cannot delete the current active environment"
    log_info "Switch to a different environment first: nself env switch <name>"
    return 1
  fi

  # Confirm deletion
  if [[ "$force" != "true" ]]; then
    printf "Are you sure you want to delete environment '%s'? [y/N] " "$env_name"
    read -r response
    response=$(printf "%s" "$response" | tr '[:upper:]' '[:lower:]')
    if [[ "$response" != "y" && "$response" != "yes" ]]; then
      log_info "Deletion cancelled"
      return 0
    fi
  fi

  rm -rf "$env_dir"
  log_success "Deleted environment: $env_name"
}

# Export functions
export -f env::init_directory
export -f env::create
export -f env::create_local_env
export -f env::create_staging_env
export -f env::create_prod_env
export -f env::create_from_template
export -f env::list
export -f env::get_current
export -f env::delete
