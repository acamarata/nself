#!/usr/bin/env bash
# switch.sh - Environment switching functionality
# POSIX-compliant, no Bash 4+ features

# Get the directory where this script is located
ENV_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_ROOT="$(dirname "$ENV_LIB_DIR")"

# Source dependencies
source "$LIB_ROOT/utils/display.sh" 2>/dev/null || true
source "$LIB_ROOT/utils/platform-compat.sh" 2>/dev/null || true
source "$ENV_LIB_DIR/create.sh" 2>/dev/null || true

# Environment directory
ENVIRONMENTS_DIR="${ENVIRONMENTS_DIR:-./.environments}"
CURRENT_ENV_FILE=".current-env"

# Switch to a different environment
env::switch() {
  local env_name="$1"
  local quiet="${2:-false}"

  if [[ -z "$env_name" ]]; then
    log_error "Environment name is required"
    return 1
  fi

  local env_dir="$ENVIRONMENTS_DIR/$env_name"

  # Check if environment exists
  if [[ ! -d "$env_dir" ]]; then
    log_error "Environment '$env_name' does not exist"
    log_info "Available environments:"
    env::list
    return 1
  fi

  # Get current environment
  local current
  current=$(env::get_current 2>/dev/null || echo "")

  if [[ "$env_name" == "$current" ]]; then
    if [[ "$quiet" != "true" ]]; then
      log_info "Already using environment: $env_name"
    fi
    return 0
  fi

  # Backup current .env files if they exist
  env::backup_current_env

  # Apply the new environment
  env::apply_env "$env_name"

  # Save current environment marker
  printf "%s" "$env_name" > "$CURRENT_ENV_FILE"

  if [[ "$quiet" != "true" ]]; then
    log_success "Switched to environment: $env_name"
    env::show_status "$env_name"
  fi

  return 0
}

# Backup current environment files
env::backup_current_env() {
  local backup_dir=".env-backups"
  local timestamp
  timestamp=$(date +%Y%m%d-%H%M%S)

  mkdir -p "$backup_dir"

  # Backup main .env if exists
  if [[ -f ".env" ]]; then
    cp ".env" "$backup_dir/.env.backup-$timestamp"
  fi

  # Backup .env.local if exists
  if [[ -f ".env.local" ]]; then
    cp ".env.local" "$backup_dir/.env.local.backup-$timestamp"
  fi

  # Cleanup old backups (keep last 10)
  local count
  count=$(ls -1 "$backup_dir"/.env.backup-* 2>/dev/null | wc -l)
  if [[ $count -gt 10 ]]; then
    ls -1t "$backup_dir"/.env.backup-* | tail -n +11 | xargs rm -f 2>/dev/null || true
  fi
}

# Apply environment configuration
env::apply_env() {
  local env_name="$1"
  local env_dir="$ENVIRONMENTS_DIR/$env_name"

  # Merge environment files with proper cascade
  # Base: .env.dev -> Environment: .env -> Secrets: .env.secrets

  # Start with project's base .env.dev if it exists
  local merged_env=""
  if [[ -f ".env.dev" ]]; then
    merged_env=$(cat ".env.dev")
  fi

  # Layer environment-specific .env
  if [[ -f "$env_dir/.env" ]]; then
    # Merge: environment values override base
    local env_content
    env_content=$(cat "$env_dir/.env")

    if [[ -n "$merged_env" ]]; then
      merged_env=$(env::merge_env_content "$merged_env" "$env_content")
    else
      merged_env="$env_content"
    fi
  fi

  # Write to .env.local (the active override file)
  printf "%s\n" "$merged_env" > ".env.local"

  # Handle secrets separately (merge into .env.secrets if it exists)
  if [[ -f "$env_dir/.env.secrets" ]]; then
    # Copy secrets to project root .env.secrets
    cp "$env_dir/.env.secrets" ".env.secrets"
    chmod 600 ".env.secrets"
  fi

  # Also create/update .env with environment indicator
  cat > ".env" <<EOF
# Active Environment: $env_name
# This file is auto-generated by nself env switch
# Edit .env.local for overrides or .environments/$env_name/.env for environment config

ENV=${env_name}

# Load environment-specific configuration
# Settings are loaded from: .env.dev -> .env.local -> .env.secrets
EOF

  log_info "Applied environment configuration from: $env_dir"
}

# Merge two environment file contents
# Second content overrides first
env::merge_env_content() {
  local base="$1"
  local overlay="$2"

  # Create temporary files
  local tmp_base
  local tmp_overlay
  local tmp_result

  tmp_base=$(mktemp)
  tmp_overlay=$(mktemp)
  tmp_result=$(mktemp)

  printf "%s" "$base" > "$tmp_base"
  printf "%s" "$overlay" > "$tmp_overlay"

  # Copy base to result
  cat "$tmp_base" > "$tmp_result"

  # Process overlay line by line
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip empty lines and comments
    if [[ -z "$line" ]] || [[ "$line" =~ ^[[:space:]]*# ]]; then
      continue
    fi

    # Extract key if this is a valid assignment
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)= ]]; then
      local key="${BASH_REMATCH[1]}"

      # Check if key exists in base
      if grep -q "^${key}=" "$tmp_result" 2>/dev/null; then
        # Replace existing line
        safe_sed_inline "$tmp_result" "s|^${key}=.*|${line}|"
      else
        # Append new line
        printf "\n%s" "$line" >> "$tmp_result"
      fi
    fi
  done < "$tmp_overlay"

  cat "$tmp_result"

  # Cleanup
  rm -f "$tmp_base" "$tmp_overlay" "$tmp_result"
}

# Show environment status
env::show_status() {
  local env_name="$1"
  local env_dir="$ENVIRONMENTS_DIR/$env_name"

  printf "\n"
  printf "Environment: ${COLOR_GREEN}%s${COLOR_RESET}\n" "$env_name"

  # Show key settings
  if [[ -f "$env_dir/.env" ]]; then
    local env_type
    local base_domain
    local ssl_enabled

    env_type=$(grep "^ENV=" "$env_dir/.env" 2>/dev/null | cut -d'=' -f2)
    base_domain=$(grep "^BASE_DOMAIN=" "$env_dir/.env" 2>/dev/null | cut -d'=' -f2)
    ssl_enabled=$(grep "^SSL_ENABLED=" "$env_dir/.env" 2>/dev/null | cut -d'=' -f2)

    printf "  Type:   %s\n" "${env_type:-development}"
    printf "  Domain: %s\n" "${base_domain:-localhost}"
    printf "  SSL:    %s\n" "${ssl_enabled:-true}"
  fi

  # Show server info if configured
  if [[ -f "$env_dir/server.json" ]]; then
    local server_host
    server_host=$(grep '"host"' "$env_dir/server.json" 2>/dev/null | cut -d'"' -f4)

    if [[ -n "$server_host" ]]; then
      printf "  Server: %s\n" "$server_host"
    fi
  fi

  printf "\n"
}

# Get environment info
env::info() {
  local env_name="${1:-$(env::get_current)}"
  local env_dir="$ENVIRONMENTS_DIR/$env_name"

  if [[ ! -d "$env_dir" ]]; then
    log_error "Environment '$env_name' does not exist"
    return 1
  fi

  printf "Environment: %s\n" "$env_name"
  printf "Path: %s\n" "$env_dir"
  printf "\n"

  # Show .env contents (masked secrets)
  if [[ -f "$env_dir/.env" ]]; then
    printf "Configuration (.env):\n"
    while IFS= read -r line || [[ -n "$line" ]]; do
      # Mask password/secret values
      if [[ "$line" =~ (PASSWORD|SECRET|KEY)= ]]; then
        local key
        key=$(printf "%s" "$line" | cut -d'=' -f1)
        printf "  %s=********\n" "$key"
      elif [[ "$line" =~ ^[A-Za-z_] ]]; then
        printf "  %s\n" "$line"
      fi
    done < "$env_dir/.env"
  fi

  # Show server info
  if [[ -f "$env_dir/server.json" ]]; then
    printf "\nServer Configuration:\n"
    cat "$env_dir/server.json" | grep -v '"key"' | head -10
  fi
}

# Restore a previous environment backup
env::restore() {
  local backup_name="$1"
  local backup_dir=".env-backups"

  if [[ -z "$backup_name" ]]; then
    # List available backups
    printf "Available backups:\n"
    ls -1t "$backup_dir"/.env.backup-* 2>/dev/null | while read -r backup; do
      printf "  %s\n" "$(basename "$backup")"
    done
    return 0
  fi

  local backup_file="$backup_dir/$backup_name"
  if [[ ! -f "$backup_file" ]]; then
    backup_file="$backup_dir/.env.backup-$backup_name"
  fi

  if [[ ! -f "$backup_file" ]]; then
    log_error "Backup not found: $backup_name"
    return 1
  fi

  cp "$backup_file" ".env"
  log_success "Restored backup: $backup_name"
}

# Export functions
export -f env::switch
export -f env::backup_current_env
export -f env::apply_env
export -f env::merge_env_content
export -f env::show_status
export -f env::info
export -f env::restore
