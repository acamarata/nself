# v0.4.6 Planning - Scaling & Performance

**Target**: Q2-Q3 2026
**Focus**: Scale and optimize for production loads

**Depends on**: v0.4.3-v0.4.5 (full environment and database stack)

---

## Overview

Complete scaling and performance optimization toolkit. Horizontal and vertical scaling, performance profiling, cross-environment migration, and benchmarking tools.

---

## New Commands

| Command | Purpose |
|---------|---------|
| `nself scale` | Horizontal/vertical scaling |
| `nself perf` | Performance profiling |
| `nself migrate` | Cross-environment migration |
| `nself bench` | Benchmarking tools |

---

## Detailed Feature Specifications

### 1. Scaling (`nself scale`)

#### Subcommands
```bash
# Vertical scaling (resources)
nself scale up <service>              # Increase resources
nself scale up postgres --memory 4G   # Set specific memory
nself scale up hasura --cpu 2         # Set CPU limit
nself scale down <service>            # Decrease resources

# Horizontal scaling (replicas)
nself scale out <service>             # Add replica
nself scale out api --replicas 3      # Set replica count
nself scale in <service>              # Remove replica
nself scale in api --replicas 1       # Set to 1

# Auto-scaling
nself scale auto <service>            # Enable auto-scaling
nself scale auto api --min 2 --max 10 # Configure auto-scaling
nself scale auto api --cpu-threshold 70
nself scale auto --disable <service>

# Status
nself scale status                    # Show scaling status
nself scale status <service>          # Service-specific
```

#### Resource Scaling Configuration

```yaml
# In docker-compose.override.yml or scaling.yaml
services:
  postgres:
    deploy:
      resources:
        limits:
          memory: 4G
          cpus: '2'
        reservations:
          memory: 2G
          cpus: '1'

  api:
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
```

#### Load Balancer Configuration

```bash
# Automatic nginx upstream configuration
nself scale out api --replicas 3

# Generates nginx.conf:
upstream api_backend {
    least_conn;
    server api_1:8080;
    server api_2:8080;
    server api_3:8080;
    keepalive 32;
}
```

#### Connection Pooling (PgBouncer)

```bash
# Enable connection pooling
nself scale pooler enable

# Configure
nself scale pooler config --pool-size 100
nself scale pooler config --pool-mode transaction

# Status
nself scale pooler status
```

#### Redis Cluster Support

```bash
# Enable Redis cluster mode
nself scale redis cluster --nodes 6

# Add nodes
nself scale redis add-node

# Status
nself scale redis status
```

---

### 2. Performance Profiling (`nself perf`)

#### Subcommands
```bash
# Profiling
nself perf profile                    # Full system profile
nself perf profile <service>          # Service-specific
nself perf profile --duration 60      # Profile for 60 seconds

# Analysis
nself perf analyze                    # Analyze current performance
nself perf analyze --slow-queries     # Focus on slow queries
nself perf analyze --memory           # Memory analysis
nself perf analyze --cpu              # CPU analysis

# Reports
nself perf report                     # Generate performance report
nself perf report --format html       # HTML report
nself perf report --compare last      # Compare to last report

# Recommendations
nself perf suggest                    # Get optimization suggestions
```

#### Slow Query Detection

```bash
nself perf slow-queries

# Output:
┌─────────────────────────────────────────────────────────────┐
│ Slow Queries (>100ms) - Last 24 hours                      │
├─────────────────────────────────────────────────────────────┤
│ 1. SELECT * FROM orders WHERE user_id = $1                 │
│    Avg: 450ms | Count: 1,234 | Missing index on user_id    │
│                                                             │
│ 2. SELECT COUNT(*) FROM products                            │
│    Avg: 320ms | Count: 567 | Consider caching              │
│                                                             │
│ 3. UPDATE users SET last_login = NOW() WHERE id = $1       │
│    Avg: 180ms | Count: 10,234 | High write contention      │
└─────────────────────────────────────────────────────────────┘

Suggested fixes:
  nself db optimize --add-index orders user_id
  nself perf cache enable count_products
```

#### Resource Usage Dashboard

```bash
nself perf dashboard

# Real-time terminal dashboard showing:
# - CPU usage per service
# - Memory usage per service
# - Request rates
# - Response times
# - Database connections
# - Cache hit rates
```

#### Performance Report

```bash
nself perf report --format markdown

# Generates:
# performance-report-2026-01-22.md
# - Executive summary
# - Resource utilization graphs
# - Slow query analysis
# - Optimization recommendations
# - Comparison with previous report
```

---

### 3. Cross-Environment Migration (`nself migrate`)

#### Subcommands
```bash
# Full migration
nself migrate staging prod            # Migrate staging to prod
nself migrate local staging           # Migrate local to staging
nself migrate --dry-run               # Preview migration

# Selective migration
nself migrate --schema-only           # Structure only
nself migrate --data-only             # Data only
nself migrate --config-only           # Configuration only

# Sync
nself migrate sync staging prod       # Keep environments in sync
nself migrate sync --watch            # Continuous sync

# Drift detection
nself migrate diff staging prod       # Show differences
nself migrate diff --schema           # Schema differences only
nself migrate diff --config           # Config differences only
```

#### Migration with Anonymization

```bash
# When migrating FROM production
nself migrate prod staging --anonymize

# Uses anonymize.yaml rules from v0.4.5
# Automatically strips PII
```

#### Configuration Drift Detection

```bash
nself migrate diff staging prod

# Output:
┌─────────────────────────────────────────────────────────────┐
│ Configuration Drift: staging → prod                         │
├─────────────────────────────────────────────────────────────┤
│ Environment Variables:                                      │
│   + REDIS_CLUSTER=true (prod only)                         │
│   ~ LOG_LEVEL: debug → info                                │
│   - DEBUG_MODE=true (staging only)                         │
│                                                             │
│ Schema:                                                     │
│   + Table: analytics_events (prod only)                    │
│   ~ Column: users.metadata (different type)                │
│                                                             │
│ Services:                                                   │
│   + prometheus-exporter (prod only)                        │
│   ~ api replicas: 1 → 3                                    │
└─────────────────────────────────────────────────────────────┘
```

#### Rollback Support

```bash
# Migrations create checkpoints
nself migrate staging prod

# If issues arise:
nself migrate rollback               # Rollback last migration
nself migrate rollback --to checkpoint-2026-01-22
```

---

### 4. Benchmarking (`nself bench`)

#### Subcommands
```bash
# API benchmarking
nself bench api                       # Benchmark all endpoints
nself bench api /users                # Specific endpoint
nself bench api --concurrent 100      # Concurrent requests
nself bench api --duration 60         # Test duration

# Database benchmarking
nself bench db                        # Overall database performance
nself bench db --read                 # Read performance
nself bench db --write                # Write performance
nself bench db --mixed                # Mixed workload

# Load testing
nself bench load                      # Simulate production load
nself bench load --users 1000         # Simulate 1000 users
nself bench load --scenario checkout  # Specific user flow

# Comparison
nself bench compare                   # Compare to baseline
nself bench compare --with last       # Compare to last run
nself bench baseline save             # Save current as baseline
```

#### Benchmark Scenarios

```yaml
# bench/scenarios/checkout.yaml
name: Checkout Flow
description: Simulate user checkout process

steps:
  - name: Browse products
    endpoint: GET /api/products
    weight: 0.4

  - name: View product
    endpoint: GET /api/products/{id}
    weight: 0.3

  - name: Add to cart
    endpoint: POST /api/cart
    weight: 0.15

  - name: Checkout
    endpoint: POST /api/checkout
    weight: 0.1

  - name: Payment
    endpoint: POST /api/payment
    weight: 0.05

settings:
  users: 100
  duration: 300
  ramp_up: 60
```

#### Benchmark Output

```bash
nself bench api --concurrent 100 --duration 60

# Output:
┌─────────────────────────────────────────────────────────────┐
│ API Benchmark Results                                       │
├─────────────────────────────────────────────────────────────┤
│ Duration: 60s | Concurrent Users: 100                       │
│                                                             │
│ Endpoint              RPS     Avg     P95     P99    Errors │
│ GET /api/users       1,234   45ms    120ms   250ms   0.1%   │
│ GET /api/products    2,456   23ms     65ms   130ms   0.0%   │
│ POST /api/orders       456   89ms    200ms   450ms   0.5%   │
│ GET /api/health     10,234    5ms     12ms    25ms   0.0%   │
│                                                             │
│ Total Requests: 245,678                                     │
│ Success Rate: 99.8%                                         │
│ Throughput: 4,094 req/s                                     │
└─────────────────────────────────────────────────────────────┘
```

---

## Implementation Files

### New CLI Commands
```
src/cli/scale.sh             # Scaling command
src/cli/perf.sh              # Performance command
src/cli/migrate.sh           # Migration command
src/cli/bench.sh             # Benchmarking command
```

### New Library Files
```
src/lib/scale/
├── vertical.sh              # Resource scaling
├── horizontal.sh            # Replica scaling
├── autoscale.sh             # Auto-scaling logic
├── loadbalancer.sh          # Nginx upstream config
├── pgbouncer.sh             # Connection pooling
└── redis-cluster.sh         # Redis clustering

src/lib/perf/
├── profile.sh               # System profiling
├── analyze.sh               # Performance analysis
├── slow-queries.sh          # Query analysis
├── dashboard.sh             # Real-time dashboard
├── report.sh                # Report generation
└── suggest.sh               # Recommendations engine

src/lib/migrate/
├── full.sh                  # Full migration
├── schema.sh                # Schema migration
├── data.sh                  # Data migration
├── config.sh                # Config migration
├── diff.sh                  # Drift detection
├── sync.sh                  # Continuous sync
└── rollback.sh              # Rollback support

src/lib/bench/
├── api.sh                   # API benchmarking
├── db.sh                    # Database benchmarking
├── load.sh                  # Load testing
├── scenarios.sh             # Scenario runner
├── compare.sh               # Result comparison
└── report.sh                # Benchmark reports
```

---

## Environment Variable Additions

```bash
# Scaling
SCALE_DEFAULT_MEMORY=512M
SCALE_DEFAULT_CPU=0.5
SCALE_AUTOSCALE_ENABLED=false
SCALE_AUTOSCALE_MIN=1
SCALE_AUTOSCALE_MAX=10
SCALE_AUTOSCALE_CPU_THRESHOLD=70

# PgBouncer
PGBOUNCER_ENABLED=false
PGBOUNCER_POOL_SIZE=100
PGBOUNCER_POOL_MODE=transaction

# Performance
PERF_SLOW_QUERY_THRESHOLD=100  # ms
PERF_REPORT_PATH=./reports
PERF_PROFILE_DURATION=60

# Benchmarking
BENCH_SCENARIOS_PATH=./bench/scenarios
BENCH_RESULTS_PATH=./bench/results
BENCH_BASELINE_PATH=./bench/baseline
```

---

## Dependencies

- `wrk` or `hey` for HTTP benchmarking
- `pgbench` for database benchmarking
- `htop`/`top` for system profiling
- `pg_stat_statements` extension for query analysis

---

## Success Criteria

1. ✓ `nself scale out api --replicas 3` creates load-balanced replicas
2. ✓ `nself perf slow-queries` identifies optimization opportunities
3. ✓ `nself migrate diff` accurately detects configuration drift
4. ✓ `nself bench api` provides accurate performance metrics
5. ✓ Auto-scaling responds to load within configured thresholds
6. ✓ PgBouncer integration improves connection handling

---

*Last Updated: January 22, 2026*
