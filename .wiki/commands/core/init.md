# nself init

**Category**: Core Commands

Initialize a new nself project with interactive wizard or quick start.

## Overview

The `init` command sets up a new nself project by creating the basic configuration structure, environment files, and directory layout.

**Features**:
- ✅ Interactive wizard with smart defaults
- ✅ Quick start mode for rapid prototyping
- ✅ Demo mode with full feature showcase
- ✅ Git integration (optional)
- ✅ Environment detection (dev/staging/prod)
- ✅ Validation of prerequisites

## Usage

```bash
nself init [OPTIONS]
```

## Options

| Option | Description | Default |
|--------|-------------|---------|
| `-q, --quick` | Quick start with minimal prompts | false |
| `-d, --demo` | Demo mode with all features enabled | false |
| `-n, --name NAME` | Project name | Interactive prompt |
| `-e, --env ENV` | Environment (dev/staging/prod) | dev |
| `--domain DOMAIN` | Base domain | localhost |
| `--no-git` | Skip git initialization | false |
| `--force` | Overwrite existing files | false |
| `-h, --help` | Show help message | - |

## Modes

### Interactive Mode (Default)

```bash
nself init
```

**Prompts for**:
1. Project name
2. Base domain
3. Database credentials
4. Optional services to enable
5. Monitoring bundle
6. Git initialization

### Quick Start Mode

```bash
nself init --quick
```

**Minimal prompts**:
- Project name only
- All other settings use smart defaults
- Perfect for rapid prototyping

### Demo Mode

```bash
nself init --demo
```

**Full showcase**:
- Enables all optional services
- Enables monitoring bundle
- Creates 4 custom services from templates
- Configures 2 frontend apps
- Perfect for exploring nself capabilities

## Examples

### Basic Interactive Setup

```bash
cd ~/myproject
nself init
```

**Output**:
```
╔═══════════════════════════════════════════════╗
║         Welcome to nself v0.9.9               ║
║     Backend-as-a-Service Made Simple          ║
╚═══════════════════════════════════════════════╝

Let's set up your project!

→ Project name: myapp
→ Base domain [localhost]:
→ Database name [myapp_db]:
→ Database user [postgres]:
→ Hasura admin secret: **************

Optional Services
→ Enable Redis? [y/N]: y
→ Enable MinIO (S3 storage)? [y/N]: y
→ Enable nself Admin UI? [y/N]: y

Monitoring
→ Enable monitoring bundle? [y/N]: n

✓ Configuration created: .env
✓ Directory structure created
✓ Git initialized (optional)

Next steps:
  nself build    # Generate configs
  nself start    # Start services
```

### Quick Start

```bash
nself init --quick --name myapp
```

**Output**:
```
→ Quick start mode enabled
✓ Project: myapp
✓ Domain: localhost
✓ Environment: dev
✓ Configuration: .env created

Next steps:
  nself build && nself start
```

### Demo Mode

```bash
nself init --demo
```

**Output**:
```
→ Demo mode: Showcasing all features
✓ All optional services enabled
✓ Monitoring bundle enabled
✓ Custom services configured (4)
✓ Frontend apps configured (2)

Demo includes:
  • Required: PostgreSQL, Hasura, Auth, Nginx
  • Optional: Redis, MinIO, Admin, MailPit, MeiliSearch, MLflow
  • Monitoring: Prometheus, Grafana, Loki + exporters
  • Custom: Express API, BullMQ Worker, gRPC, Python API
  • Frontend: App1 (pnpm), App2 (npm)

Total: 25 Docker containers

Next steps:
  nself build && nself start
```

## What Gets Created

### Files

```
myproject/
├── .env                    # Main environment configuration
├── .env.example            # Example template (optional)
├── .gitignore              # Git ignore rules (if --no-git not used)
├── README.md               # Project README (optional)
└── .git/                   # Git repository (if git enabled)
```

### Directory Structure

```
myproject/
├── hasura/                 # Hasura metadata (created on first build)
│   ├── migrations/
│   ├── metadata/
│   └── seeds/
├── db/                     # Database files (optional, user-managed)
│   ├── migrations/
│   └── seeds/
├── nginx/                  # Generated by nself build
├── ssl/                    # Generated by nself build
├── services/               # Custom services (if configured)
└── monitoring/             # Monitoring configs (if enabled)
```

## Environment File Structure

The generated `.env` file contains:

```bash
# Project Information
PROJECT_NAME=myapp
ENV=dev
BASE_DOMAIN=localhost

# Database (Required)
POSTGRES_DB=myapp_db
POSTGRES_USER=postgres
POSTGRES_PASSWORD=secure-password-here
POSTGRES_PORT=5432

# Hasura (Required)
HASURA_GRAPHQL_ADMIN_SECRET=admin-secret-here
HASURA_PORT=8080

# Auth (Required)
AUTH_JWT_SECRET=jwt-secret-here
AUTH_PORT=4000

# Optional Services (disabled by default)
REDIS_ENABLED=false
MINIO_ENABLED=false
NSELF_ADMIN_ENABLED=false
MAILPIT_ENABLED=false
MEILISEARCH_ENABLED=false
MLFLOW_ENABLED=false

# Monitoring Bundle (disabled by default)
MONITORING_ENABLED=false

# Custom Services (examples)
# CS_1=api:express-js:8001
# CS_2=worker:bullmq-js:8002

# Frontend Applications (examples)
# FRONTEND_APP_1_NAME=app1
# FRONTEND_APP_1_PORT=3000
# FRONTEND_APP_1_ROUTE=app1
```

## Prerequisites Check

Before initialization, nself verifies:

1. **Docker** - Required for all services
2. **Docker Compose** - Required for orchestration
3. **Git** - Optional, for version control
4. **Node.js** - Optional, for custom services
5. **Sufficient disk space** - Minimum 2GB recommended

**If missing**:
```bash
✗ Docker not found. Please install Docker Desktop.
  → https://docs.docker.com/get-docker/

✗ Docker Compose not found.
  → Included with Docker Desktop
```

## Validation

The init command validates:

- Project name (alphanumeric, hyphens, underscores only)
- Domain format (valid DNS format)
- Port availability (checks for conflicts)
- File permissions (write access)
- Existing files (prevents overwrite without --force)

**Example validation errors**:
```bash
✗ Invalid project name: "my project" (spaces not allowed)
✗ Port 5432 already in use
✗ .env already exists (use --force to overwrite)
```

## Git Integration

When git is enabled (default):

```bash
# Initialized
git init
git add .env.example README.md
git commit -m "Initial commit: nself project setup"

# .gitignore includes
.env
.env.local
.env.staging
.env.prod
.secrets
docker-compose.yml
nginx/
ssl/
```

**Skip git**:
```bash
nself init --no-git
```

## Best Practices

### 1. Use Version Control

```bash
nself init  # Includes git by default
```

### 2. Separate Environments

```bash
# Development
nself init --env dev

# Staging (on staging server)
nself init --env staging --domain staging.example.com

# Production (on prod server)
nself init --env prod --domain example.com
```

### 3. Secure Credentials

```bash
# After init, update credentials
vi .env

# Change:
POSTGRES_PASSWORD=secure-random-password
HASURA_GRAPHQL_ADMIN_SECRET=secure-random-secret
AUTH_JWT_SECRET=secure-random-jwt-secret
```

### 4. Start Small, Scale Up

```bash
# Start with quick mode
nself init --quick

# Enable services as needed later
# Edit .env and set *_ENABLED=true
```

## Troubleshooting

### Already initialized

**Error**:
```
✗ .env already exists (project already initialized)
```

**Solutions**:
```bash
# Use force to overwrite
nself init --force

# Or manually remove
rm .env
nself init
```

### Port conflicts

**Error**:
```
✗ Port 5432 already in use (PostgreSQL)
```

**Solution**:
```bash
# Change port in .env after init
POSTGRES_PORT=5433

# Or stop conflicting service
docker stop existing-postgres
```

### Permission denied

**Error**:
```
✗ Permission denied: Cannot write to directory
```

**Solution**:
```bash
# Fix directory permissions
chmod u+w .

# Or run from different directory
cd ~/projects
mkdir myapp && cd myapp
nself init
```

## Related Commands

- `nself build` - Generate configuration files after init
- `nself start` - Start services after init and build
- `nself config show` - View current configuration
- `nself version` - Check nself version

## See Also

- [nself build](build.md)
- [nself start](start.md)
- [Quick Start Guide](../../quick-start/README.md)
- [Configuration Reference](../../configuration/README.md)
