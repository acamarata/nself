package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"sync"
	"time"

	"github.com/gorilla/mux"
	"github.com/go-redis/redis/v8"
)

// Data structures
type CurrencyRate struct {
	BaseCurrency   string    `json:"base_currency"`
	TargetCurrency string    `json:"target_currency"`
	Rate           float64   `json:"rate"`
	Source         string    `json:"source"`
	Timestamp      time.Time `json:"timestamp"`
}

type CryptoPrice struct {
	Symbol      string    `json:"symbol"`
	VsCurrency  string    `json:"vs_currency"`
	Price       float64   `json:"price"`
	MarketCap   float64   `json:"market_cap"`
	Volume24h   float64   `json:"volume_24h"`
	Change24h   float64   `json:"change_24h"`
	Source      string    `json:"source"`
	Timestamp   time.Time `json:"timestamp"`
}

type MetalPrice struct {
	Metal      string    `json:"metal"`
	PricePerOz float64   `json:"price_per_oz"`
	Currency   string    `json:"currency"`
	Change24h  float64   `json:"change_24h"`
	Source     string    `json:"source"`
	Timestamp  time.Time `json:"timestamp"`
}

type FetchResult struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data,omitempty"`
	Error   string      `json:"error,omitempty"`
	Type    string      `json:"type"`
}

// Configuration
type Config struct {
	RedisURL      string
	HasuraURL     string
	HasuraSecret  string
	FetchInterval time.Duration
	Port          string
}

// Services
type CurrencyFetcher struct {
	config      Config
	redisClient *redis.Client
	httpClient  *http.Client
}

func NewCurrencyFetcher(config Config) *CurrencyFetcher {
	// Redis client
	opt, err := redis.ParseURL(config.RedisURL)
	if err != nil {
		log.Printf("Warning: Redis connection failed: %v", err)
		opt = &redis.Options{
			Addr: "redis:6379",
		}
	}
	
	rdb := redis.NewClient(opt)
	
	// HTTP client with connection pooling
	transport := &http.Transport{
		MaxIdleConnsPerHost: 100,
		MaxConnsPerHost:     100,
		IdleConnTimeout:     90 * time.Second,
	}
	
	return &CurrencyFetcher{
		config:      config,
		redisClient: rdb,
		httpClient: &http.Client{
			Transport: transport,
			Timeout:   30 * time.Second,
		},
	}
}

// High-performance concurrent fetching
func (cf *CurrencyFetcher) FetchAllRates(ctx context.Context) map[string]FetchResult {
	results := make(map[string]FetchResult)
	var mu sync.Mutex
	var wg sync.WaitGroup

	// Define what to fetch
	tasks := []struct {
		name string
		fn   func(context.Context) (interface{}, error)
	}{
		{"exchange_rates", cf.fetchExchangeRates},
		{"crypto_prices", cf.fetchCryptoPrices},
		{"metal_prices", cf.fetchMetalPrices},
	}

	// Execute all tasks concurrently
	for _, task := range tasks {
		wg.Add(1)
		go func(taskName string, taskFn func(context.Context) (interface{}, error)) {
			defer wg.Done()
			
			start := time.Now()
			data, err := taskFn(ctx)
			duration := time.Since(start)
			
			mu.Lock()
			if err != nil {
				results[taskName] = FetchResult{
					Success: false,
					Error:   err.Error(),
					Type:    taskName,
				}
				log.Printf("❌ %s failed in %v: %v", taskName, duration, err)
			} else {
				results[taskName] = FetchResult{
					Success: true,
					Data:    data,
					Type:    taskName,
				}
				log.Printf("✅ %s completed in %v", taskName, duration)
			}
			mu.Unlock()
		}(task.name, task.fn)
	}

	wg.Wait()
	return results
}

func (cf *CurrencyFetcher) fetchExchangeRates(ctx context.Context) (interface{}, error) {
	// Major currency pairs
	baseCurrency := "USD"
	targetCurrencies := []string{"EUR", "GBP", "JPY", "AUD", "CAD", "CHF", "CNY", "SEK", "NOK", "DKK"}
	
	rates := make([]CurrencyRate, 0, len(targetCurrencies))
	
	// In production, you'd use a real API like:
	// - ExchangeRate-API.com
	// - Fixer.io
	// - CurrencyAPI.com
	
	// For now, simulate realistic rates with some variation
	baseRates := map[string]float64{
		"EUR": 0.85, "GBP": 0.73, "JPY": 110.0, "AUD": 1.35,
		"CAD": 1.25, "CHF": 0.92, "CNY": 6.45, "SEK": 8.5,
		"NOK": 8.8, "DKK": 6.3,
	}
	
	var wg sync.WaitGroup
	var mu sync.Mutex
	
	for _, target := range targetCurrencies {
		wg.Add(1)
		go func(targetCur string) {
			defer wg.Done()
			
			// Simulate API call delay
			time.Sleep(time.Duration(50+len(targetCur)*10) * time.Millisecond)
			
			baseRate := baseRates[targetCur]
			if baseRate == 0 {
				baseRate = 1.0
			}
			
			// Add realistic variation (+/- 2%)
			variation := 1 + (cf.randomFloat()*0.04 - 0.02)
			rate := baseRate * variation
			
			currencyRate := CurrencyRate{
				BaseCurrency:   baseCurrency,
				TargetCurrency: targetCur,
				Rate:           cf.roundToDecimal(rate, 4),
				Source:         "simulated",
				Timestamp:      time.Now(),
			}
			
			mu.Lock()
			rates = append(rates, currencyRate)
			mu.Unlock()
			
			// Store in database and cache
			go cf.storeCurrencyRate(currencyRate)
			go cf.cacheCurrencyRate(currencyRate)
		}(target)
	}
	
	wg.Wait()
	return rates, nil
}

func (cf *CurrencyFetcher) fetchCryptoPrices(ctx context.Context) (interface{}, error) {
	cryptos := []string{"BTC", "ETH", "ADA", "DOT", "SOL", "AVAX", "MATIC", "LINK", "UNI", "ATOM"}
	prices := make([]CryptoPrice, 0, len(cryptos))
	
	// Base prices for simulation
	basePrices := map[string]float64{
		"BTC": 45000, "ETH": 3000, "ADA": 0.5, "DOT": 7.5, "SOL": 100,
		"AVAX": 25, "MATIC": 0.8, "LINK": 15, "UNI": 6, "ATOM": 12,
	}
	
	var wg sync.WaitGroup
	var mu sync.Mutex
	
	for _, crypto := range cryptos {
		wg.Add(1)
		go func(symbol string) {
			defer wg.Done()
			
			// Simulate API call
			time.Sleep(time.Duration(30+len(symbol)*5) * time.Millisecond)
			
			basePrice := basePrices[symbol]
			if basePrice == 0 {
				basePrice = 1.0
			}
			
			// Add crypto-like volatility (+/- 10%)
			variation := 1 + (cf.randomFloat()*0.2 - 0.1)
			price := basePrice * variation
			
			cryptoPrice := CryptoPrice{
				Symbol:     symbol,
				VsCurrency: "USD",
				Price:      cf.roundToDecimal(price, 2),
				MarketCap:  cf.roundToDecimal(price*cf.randomFloat()*1000000000, 0),
				Volume24h:  cf.roundToDecimal(price*cf.randomFloat()*100000000, 0),
				Change24h:  cf.roundToDecimal((cf.randomFloat()-0.5)*20, 2),
				Source:     "simulated",
				Timestamp:  time.Now(),
			}
			
			mu.Lock()
			prices = append(prices, cryptoPrice)
			mu.Unlock()
			
			// Store and cache asynchronously
			go cf.storeCryptoPrice(cryptoPrice)
			go cf.cacheCryptoPrice(cryptoPrice)
		}(crypto)
	}
	
	wg.Wait()
	return prices, nil
}

func (cf *CurrencyFetcher) fetchMetalPrices(ctx context.Context) (interface{}, error) {
	metals := []string{"GOLD", "SILVER", "PLATINUM", "PALLADIUM", "COPPER", "ALUMINUM"}
	prices := make([]MetalPrice, 0, len(metals))
	
	basePrices := map[string]float64{
		"GOLD": 1950, "SILVER": 24, "PLATINUM": 1000,
		"PALLADIUM": 2300, "COPPER": 4.2, "ALUMINUM": 2.1,
	}
	
	var wg sync.WaitGroup
	var mu sync.Mutex
	
	for _, metal := range metals {
		wg.Add(1)
		go func(metalName string) {
			defer wg.Done()
			
			// Simulate API call
			time.Sleep(time.Duration(40+len(metalName)*8) * time.Millisecond)
			
			basePrice := basePrices[metalName]
			if basePrice == 0 {
				basePrice = 100.0
			}
			
			// Add metal price variation (+/- 3%)
			variation := 1 + (cf.randomFloat()*0.06 - 0.03)
			price := basePrice * variation
			
			metalPrice := MetalPrice{
				Metal:      metalName,
				PricePerOz: cf.roundToDecimal(price, 2),
				Currency:   "USD",
				Change24h:  cf.roundToDecimal((cf.randomFloat()-0.5)*6, 2),
				Source:     "simulated",
				Timestamp:  time.Now(),
			}
			
			mu.Lock()
			prices = append(prices, metalPrice)
			mu.Unlock()
			
			// Store and cache asynchronously
			go cf.storeMetalPrice(metalPrice)
			go cf.cacheMetalPrice(metalPrice)
		}(metal)
	}
	
	wg.Wait()
	return prices, nil
}

// Database storage functions
func (cf *CurrencyFetcher) storeCurrencyRate(rate CurrencyRate) {
	mutation := `
		mutation InsertExchangeRate($data: exchange_rates_insert_input!) {
			insert_exchange_rates_one(object: $data) {
				id
			}
		}
	`
	
	variables := map[string]interface{}{
		"data": map[string]interface{}{
			"base_currency":   rate.BaseCurrency,
			"target_currency": rate.TargetCurrency,
			"rate":            rate.Rate,
			"source":          rate.Source,
			"created_at":      rate.Timestamp.Format(time.RFC3339),
		},
	}
	
	cf.executeHasuraMutation(mutation, variables)
}

func (cf *CurrencyFetcher) storeCryptoPrice(price CryptoPrice) {
	mutation := `
		mutation InsertCryptoPrice($data: crypto_prices_insert_input!) {
			insert_crypto_prices_one(object: $data) {
				id
			}
		}
	`
	
	variables := map[string]interface{}{
		"data": map[string]interface{}{
			"symbol":      price.Symbol,
			"vs_currency": price.VsCurrency,
			"price":       price.Price,
			"market_cap":  price.MarketCap,
			"volume_24h":  price.Volume24h,
			"change_24h":  price.Change24h,
			"source":      price.Source,
			"created_at":  price.Timestamp.Format(time.RFC3339),
		},
	}
	
	cf.executeHasuraMutation(mutation, variables)
}

func (cf *CurrencyFetcher) storeMetalPrice(price MetalPrice) {
	mutation := `
		mutation InsertMetalPrice($data: metal_prices_insert_input!) {
			insert_metal_prices_one(object: $data) {
				id
			}
		}
	`
	
	variables := map[string]interface{}{
		"data": map[string]interface{}{
			"metal":        price.Metal,
			"price_per_oz": price.PricePerOz,
			"currency":     price.Currency,
			"change_24h":   price.Change24h,
			"source":       price.Source,
			"created_at":   price.Timestamp.Format(time.RFC3339),
		},
	}
	
	cf.executeHasuraMutation(mutation, variables)
}

func (cf *CurrencyFetcher) executeHasuraMutation(mutation string, variables map[string]interface{}) {
	payload := map[string]interface{}{
		"query":     mutation,
		"variables": variables,
	}
	
	jsonData, err := json.Marshal(payload)
	if err != nil {
		log.Printf("Error marshaling Hasura request: %v", err)
		return
	}
	
	req, err := http.NewRequest("POST", cf.config.HasuraURL, bytes.NewBuffer(jsonData))
	if err != nil {
		log.Printf("Error creating Hasura request: %v", err)
		return
	}
	
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Hasura-Admin-Secret", cf.config.HasuraSecret)
	
	resp, err := cf.httpClient.Do(req)
	if err != nil {
		log.Printf("Error executing Hasura mutation: %v", err)
		return
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		log.Printf("Hasura mutation failed: %s", string(body))
	}
}

// Redis caching functions
func (cf *CurrencyFetcher) cacheCurrencyRate(rate CurrencyRate) {
	ctx := context.Background()
	key := fmt.Sprintf("rate:current:%s:%s", rate.BaseCurrency, rate.TargetCurrency)
	
	data, err := json.Marshal(rate)
	if err != nil {
		log.Printf("Error marshaling rate for cache: %v", err)
		return
	}
	
	err = cf.redisClient.Set(ctx, key, data, 10*time.Minute).Err()
	if err != nil {
		log.Printf("Error caching rate: %v", err)
	}
}

func (cf *CurrencyFetcher) cacheCryptoPrice(price CryptoPrice) {
	ctx := context.Background()
	key := fmt.Sprintf("crypto:current:%s:%s", price.Symbol, price.VsCurrency)
	
	data, err := json.Marshal(price)
	if err != nil {
		log.Printf("Error marshaling crypto price for cache: %v", err)
		return
	}
	
	err = cf.redisClient.Set(ctx, key, data, 5*time.Minute).Err()
	if err != nil {
		log.Printf("Error caching crypto price: %v", err)
	}
}

func (cf *CurrencyFetcher) cacheMetalPrice(price MetalPrice) {
	ctx := context.Background()
	key := fmt.Sprintf("metal:current:%s", price.Metal)
	
	data, err := json.Marshal(price)
	if err != nil {
		log.Printf("Error marshaling metal price for cache: %v", err)
		return
	}
	
	err = cf.redisClient.Set(ctx, key, data, 15*time.Minute).Err()
	if err != nil {
		log.Printf("Error caching metal price: %v", err)
	}
}

// Utility functions
func (cf *CurrencyFetcher) randomFloat() float64 {
	// Simple pseudo-random number generator
	// In production, use crypto/rand for better randomness
	return float64(time.Now().UnixNano()%1000000) / 1000000.0
}

func (cf *CurrencyFetcher) roundToDecimal(val float64, precision int) float64 {
	multiplier := 1.0
	for i := 0; i < precision; i++ {
		multiplier *= 10
	}
	return float64(int(val*multiplier+0.5)) / multiplier
}

// HTTP handlers
func (cf *CurrencyFetcher) fetchHandler(w http.ResponseWriter, r *http.Request) {
	ctx := context.Background()
	
	start := time.Now()
	results := cf.FetchAllRates(ctx)
	duration := time.Since(start)
	
	response := map[string]interface{}{
		"success":      true,
		"results":      results,
		"fetch_time":   duration.String(),
		"timestamp":    time.Now(),
		"total_items":  cf.countTotalItems(results),
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
	
	log.Printf("🚀 Fetched all rates in %v", duration)
}

func (cf *CurrencyFetcher) healthHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	
	// Check Redis connection
	ctx := context.Background()
	_, redisErr := cf.redisClient.Ping(ctx).Result()
	
	status := "ok"
	if redisErr != nil {
		status = "degraded"
	}
	
	response := map[string]interface{}{
		"status":     status,
		"service":    "currency-fetcher",
		"timestamp":  time.Now(),
		"redis":      redisErr == nil,
		"version":    "1.0.0",
	}
	
	json.NewEncoder(w).Encode(response)
}

func (cf *CurrencyFetcher) countTotalItems(results map[string]FetchResult) int {
	total := 0
	for _, result := range results {
		if result.Success {
			switch data := result.Data.(type) {
			case []CurrencyRate:
				total += len(data)
			case []CryptoPrice:
				total += len(data)
			case []MetalPrice:
				total += len(data)
			}
		}
	}
	return total
}

// Background worker
func (cf *CurrencyFetcher) startBackgroundFetcher() {
	ticker := time.NewTicker(cf.config.FetchInterval)
	defer ticker.Stop()
	
	log.Printf("🔄 Starting background fetcher (interval: %v)", cf.config.FetchInterval)
	
	for {
		select {
		case <-ticker.C:
			ctx := context.Background()
			start := time.Now()
			results := cf.FetchAllRates(ctx)
			duration := time.Since(start)
			
			successCount := 0
			for _, result := range results {
				if result.Success {
					successCount++
				}
			}
			
			log.Printf("⏰ Background fetch completed: %d/%d successful in %v", 
				successCount, len(results), duration)
		}
	}
}

// Configuration
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func main() {
	config := Config{
		RedisURL:      getEnv("REDIS_URL", "redis://redis:6379"),
		HasuraURL:     getEnv("HASURA_ENDPOINT", "http://hasura:8080/v1/graphql"),
		HasuraSecret:  getEnv("HASURA_ADMIN_SECRET", "hasura-admin-secret"),
		FetchInterval: 5 * time.Minute, // Fetch every 5 minutes
		Port:          getEnv("PORT", "3300"),
	}
	
	fetcher := NewCurrencyFetcher(config)
	
	// Setup routes
	r := mux.NewRouter()
	r.HandleFunc("/health", fetcher.healthHandler).Methods("GET")
	r.HandleFunc("/fetch", fetcher.fetchHandler).Methods("GET", "POST")
	r.HandleFunc("/", fetcher.healthHandler).Methods("GET")
	
	// CORS middleware
	r.Use(func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
			
			if r.Method == "OPTIONS" {
				w.WriteHeader(http.StatusOK)
				return
			}
			
			next.ServeHTTP(w, r)
		})
	})
	
	// Start background fetcher
	go fetcher.startBackgroundFetcher()
	
	fmt.Printf("🚀 Currency Fetcher is running on port %s\n", config.Port)
	fmt.Printf("📊 Background fetching every %v\n", config.FetchInterval)
	fmt.Printf("🔗 Health check: http://localhost:%s/health\n", config.Port)
	fmt.Printf("💱 Manual fetch: http://localhost:%s/fetch\n", config.Port)
	
	log.Fatal(http.ListenAndServe(":"+config.Port, r))
}