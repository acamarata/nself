"""
${SERVICE_NAME} - Production-ready Python microservice
"""

import asyncio
import os
import signal
import sys
from contextlib import asynccontextmanager
from datetime import datetime
from typing import Any, Dict, Optional

import asyncpg
import httpx
import redis.asyncio as redis
import uvicorn
from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

# Configuration
class Config:
    SERVICE_NAME = os.getenv("SERVICE_NAME", "${SERVICE_NAME}")
    PORT = int(os.getenv("PORT", "${SERVICE_PORT}"))
    DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://postgres:password@postgres:5432/postgres")
    REDIS_URL = os.getenv("REDIS_URL", "redis://:password@redis:6379/0")
    HASURA_ENDPOINT = os.getenv("HASURA_ENDPOINT", "http://hasura:8080/v1/graphql")
    HASURA_ADMIN_SECRET = os.getenv("HASURA_ADMIN_SECRET", "")
    LOG_LEVEL = os.getenv("LOG_LEVEL", "info")
    CORS_ORIGINS = os.getenv("CORS_ORIGINS", "*").split(",")

config = Config()

# Global connections
db_pool: Optional[asyncpg.Pool] = None
redis_client: Optional[redis.Redis] = None
websocket_connections: set[WebSocket] = set()

# Pydantic models
class HealthCheck(BaseModel):
    status: str = Field(..., description="Service health status")
    service: str = Field(..., description="Service name")
    time: datetime = Field(default_factory=datetime.utcnow)
    checks: Dict[str, str] = Field(default_factory=dict)

class Message(BaseModel):
    type: str
    data: Dict[str, Any]
    timestamp: datetime = Field(default_factory=datetime.utcnow)

# Lifespan context manager for startup/shutdown
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Handle startup and shutdown events"""
    # Startup
    print(f"üöÄ Starting {config.SERVICE_NAME} on port {config.PORT}")
    
    # Initialize PostgreSQL
    global db_pool
    try:
        db_pool = await asyncpg.create_pool(
            config.DATABASE_URL,
            min_size=5,
            max_size=20,
            max_inactive_connection_lifetime=300,
            command_timeout=60
        )
        print("‚úÖ PostgreSQL connected")
    except Exception as e:
        print(f"‚ùå PostgreSQL connection failed: {e}")
    
    # Initialize Redis
    global redis_client
    try:
        redis_client = await redis.from_url(
            config.REDIS_URL,
            encoding="utf-8",
            decode_responses=True
        )
        await redis_client.ping()
        print("‚úÖ Redis connected")
    except Exception as e:
        print(f"‚ùå Redis connection failed: {e}")
    
    yield
    
    # Shutdown
    print("üõë Shutting down gracefully...")
    
    # Close WebSocket connections
    for ws in websocket_connections:
        await ws.close()
    
    # Close database pool
    if db_pool:
        await db_pool.close()
    
    # Close Redis connection
    if redis_client:
        await redis_client.close()
    
    print("‚úÖ Shutdown complete")

# Create FastAPI app
app = FastAPI(
    title=config.SERVICE_NAME,
    version="1.0.0",
    lifespan=lifespan
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=config.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Health check endpoint
@app.get("/health", response_model=HealthCheck)
async def health_check():
    """Health check endpoint"""
    health = HealthCheck(
        status="healthy",
        service=config.SERVICE_NAME,
        checks={}
    )
    
    # Check PostgreSQL
    if db_pool:
        try:
            async with db_pool.acquire() as conn:
                await conn.fetchval("SELECT 1")
            health.checks["postgres"] = "healthy"
        except Exception:
            health.checks["postgres"] = "unhealthy"
            health.status = "degraded"
    else:
        health.checks["postgres"] = "not_connected"
    
    # Check Redis
    if redis_client:
        try:
            await redis_client.ping()
            health.checks["redis"] = "healthy"
        except Exception:
            health.checks["redis"] = "unhealthy"
            health.status = "degraded"
    else:
        health.checks["redis"] = "not_connected"
    
    return health

# Ready check endpoint
@app.get("/ready")
async def ready_check():
    """Readiness check endpoint"""
    if not db_pool or not redis_client:
        raise HTTPException(status_code=503, detail="Service not ready")
    
    try:
        # Check database
        async with db_pool.acquire() as conn:
            await conn.fetchval("SELECT 1")
        
        # Check Redis
        await redis_client.ping()
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Dependencies not ready: {e}")
    
    return {"status": "ready"}

# WebSocket endpoint
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket connection handler"""
    await websocket.accept()
    websocket_connections.add(websocket)
    
    try:
        print(f"Client connected. Total connections: {len(websocket_connections)}")
        
        # Send welcome message
        await websocket.send_json({
            "type": "connected",
            "data": {"service": config.SERVICE_NAME},
            "timestamp": datetime.utcnow().isoformat()
        })
        
        while True:
            # Receive message
            data = await websocket.receive_json()
            
            # Process message
            message = Message(type=data.get("type", "message"), data=data)
            
            # Echo to all connected clients
            for ws in websocket_connections:
                if ws.client_state.CONNECTED:
                    await ws.send_json(message.model_dump(mode="json"))
            
            # Store in Redis for persistence
            if redis_client:
                await redis_client.lpush(
                    f"messages:{config.SERVICE_NAME}",
                    message.model_dump_json()
                )
                await redis_client.ltrim(f"messages:{config.SERVICE_NAME}", 0, 999)
    
    except WebSocketDisconnect:
        print(f"Client disconnected. Total connections: {len(websocket_connections) - 1}")
    except Exception as e:
        print(f"WebSocket error: {e}")
    finally:
        websocket_connections.discard(websocket)

# Example API endpoint
@app.get("/api")
async def api_endpoint():
    """Example API endpoint"""
    return {
        "service": config.SERVICE_NAME,
        "message": f"Hello from {config.SERVICE_NAME}",
        "time": datetime.utcnow()
    }

# Database query example
@app.get("/api/data")
async def get_data():
    """Example database query"""
    if not db_pool:
        raise HTTPException(status_code=503, detail="Database not available")
    
    try:
        async with db_pool.acquire() as conn:
            # Example query - adjust to your schema
            result = await conn.fetch("""
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public' 
                LIMIT 10
            """)
            return {"tables": [dict(row) for row in result]}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Redis cache example
@app.get("/api/cache/{key}")
async def get_cache(key: str):
    """Get value from Redis cache"""
    if not redis_client:
        raise HTTPException(status_code=503, detail="Redis not available")
    
    value = await redis_client.get(key)
    if value is None:
        raise HTTPException(status_code=404, detail="Key not found")
    
    return {"key": key, "value": value}

@app.post("/api/cache/{key}")
async def set_cache(key: str, value: str, ttl: int = 3600):
    """Set value in Redis cache"""
    if not redis_client:
        raise HTTPException(status_code=503, detail="Redis not available")
    
    await redis_client.setex(key, ttl, value)
    return {"key": key, "value": value, "ttl": ttl}

# Hasura GraphQL query example
async def query_hasura(query: str, variables: Optional[Dict] = None):
    """Execute GraphQL query against Hasura"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            config.HASURA_ENDPOINT,
            json={"query": query, "variables": variables or {}},
            headers={"X-Hasura-Admin-Secret": config.HASURA_ADMIN_SECRET}
        )
        response.raise_for_status()
        return response.json()

@app.post("/api/graphql")
async def graphql_proxy(query: str, variables: Optional[Dict] = None):
    """Proxy GraphQL queries to Hasura"""
    try:
        result = await query_hasura(query, variables)
        return result
    except httpx.HTTPError as e:
        raise HTTPException(status_code=502, detail=f"Hasura error: {e}")

# Graceful shutdown handler
def handle_shutdown(signum, frame):
    """Handle shutdown signals"""
    print(f"\nReceived signal {signum}, shutting down...")
    sys.exit(0)

# Register signal handlers
signal.signal(signal.SIGINT, handle_shutdown)
signal.signal(signal.SIGTERM, handle_shutdown)

# Run the application
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=config.PORT,
        reload=False,
        log_level=config.LOG_LEVEL.lower(),
        access_log=True
    )