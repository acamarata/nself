import express from 'express';
import { Queue } from 'bullmq';

// Redis connection
const redisConfig = {
  host: process.env.REDIS_HOST || 'redis',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD || undefined,
};

// Initialize queues
const weatherQueue = new Queue('weather-processing', { connection: redisConfig });
const currencyQueue = new Queue('currency-processing', { connection: redisConfig });
const analysisQueue = new Queue('data-analysis', { connection: redisConfig });

// Express app for webhook handlers
const app = express();
app.use(express.json());

// Webhook handler for weather data insertions
app.post('/webhook/weather-inserted', async (req, res) => {
  try {
    const { event, table, op, data } = req.body;
    
    console.log(`ðŸŒ¤ï¸  Weather data inserted for ${data.new.city}, ${data.new.country}`);
    
    // Queue analysis jobs for the new weather data
    await Promise.all([
      // Queue trend analysis
      analysisQueue.add(
        'analyze-weather-trend',
        {
          data_type: 'weather',
          symbol: data.new.city,
          trigger: 'real-time',
          event_id: event.id,
        },
        {
          delay: 1000, // Wait 1 second to allow for any related inserts
          removeOnComplete: 10,
          removeOnFail: 3,
        }
      ),
      
      // Queue anomaly detection
      analysisQueue.add(
        'detect-weather-anomalies',
        {
          data_type: 'weather',
          symbol: data.new.city,
          sensitivity: 2.5,
          window_size: 24,
          trigger_event: event.id,
        },
        {
          delay: 2000,
          removeOnComplete: 5,
          removeOnFail: 2,
        }
      ),
      
      // Queue aggregation if this is a significant temperature reading
      ...(Math.abs(data.new.temperature) > 35 ? [
        weatherQueue.add(
          'process-weather-alerts',
          {
            city: data.new.city,
            country: data.new.country,
            temperature: data.new.temperature,
            thresholds: { maxTemp: 35, minTemp: -10 },
            alert_type: 'extreme_temperature',
          },
          {
            priority: 1, // High priority for alerts
            removeOnComplete: 20,
            removeOnFail: 5,
          }
        )
      ] : [])
    ]);
    
    res.status(200).json({ 
      success: true, 
      message: 'Weather data processing queued',
      jobs_queued: Math.abs(data.new.temperature) > 35 ? 3 : 2
    });
  } catch (error) {
    console.error('Weather webhook error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Webhook handler for crypto price insertions
app.post('/webhook/crypto-inserted', async (req, res) => {
  try {
    const { event, table, op, data } = req.body;
    
    console.log(`ðŸ’° Crypto price inserted for ${data.new.symbol}: $${data.new.price}`);
    
    // Queue analysis jobs for the new crypto data
    await Promise.all([
      // Queue trend analysis
      analysisQueue.add(
        'analyze-crypto-trend',
        {
          data_type: 'crypto',
          symbol: data.new.symbol,
          vs_currency: data.new.vs_currency,
          current_price: data.new.price,
          trigger: 'real-time',
        },
        {
          delay: 500,
          removeOnComplete: 15,
          removeOnFail: 3,
        }
      ),
      
      // Queue volatility analysis for significant price changes
      ...(Math.abs(data.new.change_24h) > 5 ? [
        analysisQueue.add(
          'analyze-crypto-volatility',
          {
            symbol: data.new.symbol,
            price: data.new.price,
            change_24h: data.new.change_24h,
            volume_24h: data.new.volume_24h,
            alert_threshold: 5,
          },
          {
            priority: 2,
            removeOnComplete: 10,
            removeOnFail: 2,
          }
        )
      ] : []),
      
      // Queue market correlation analysis for major coins
      ...(['BTC', 'ETH'].includes(data.new.symbol) ? [
        analysisQueue.add(
          'analyze-market-correlation',
          {
            primary_symbol: data.new.symbol,
            market_cap: data.new.market_cap,
            price_movement: data.new.change_24h,
            analysis_window: '4h',
          },
          {
            delay: 5000, // Wait for other coins to update
            removeOnComplete: 5,
            removeOnFail: 2,
          }
        )
      ] : [])
    ]);
    
    res.status(200).json({ 
      success: true, 
      message: 'Crypto analysis queued',
      symbol: data.new.symbol,
      jobs_queued: 1 + (Math.abs(data.new.change_24h) > 5 ? 1 : 0) + (['BTC', 'ETH'].includes(data.new.symbol) ? 1 : 0)
    });
  } catch (error) {
    console.error('Crypto webhook error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Webhook handler for exchange rate insertions
app.post('/webhook/exchange-rate-inserted', async (req, res) => {
  try {
    const { event, table, op, data } = req.body;
    
    console.log(`ðŸ’± Exchange rate inserted: ${data.new.base_currency}/${data.new.target_currency} = ${data.new.rate}`);
    
    // Queue analysis jobs for the new exchange rate
    await Promise.all([
      // Queue trend analysis
      analysisQueue.add(
        'analyze-currency-trend',
        {
          data_type: 'currency',
          base_currency: data.new.base_currency,
          target_currency: data.new.target_currency,
          current_rate: data.new.rate,
          timeframe: '24h',
        },
        {
          delay: 1000,
          removeOnComplete: 10,
          removeOnFail: 3,
        }
      ),
      
      // Queue cross-rate calculations for major currencies
      ...(data.new.base_currency === 'USD' && ['EUR', 'GBP', 'JPY'].includes(data.new.target_currency) ? [
        currencyQueue.add(
          'calculate-cross-rates',
          {
            updated_pair: `${data.new.base_currency}/${data.new.target_currency}`,
            new_rate: data.new.rate,
            calculate_crosses: true,
          },
          {
            priority: 3,
            removeOnComplete: 5,
            removeOnFail: 2,
          }
        )
      ] : [])
    ]);
    
    res.status(200).json({ 
      success: true, 
      message: 'Currency analysis queued',
      pair: `${data.new.base_currency}/${data.new.target_currency}`
    });
  } catch (error) {
    console.error('Currency webhook error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Webhook handler for weather data updates (significant changes)
app.post('/webhook/weather-updated', async (req, res) => {
  try {
    const { event, table, op, data } = req.body;
    const { old: oldData, new: newData } = data;
    
    console.log(`ðŸŒ¡ï¸  Weather updated for ${newData.city}: ${oldData.temperature}Â°C â†’ ${newData.temperature}Â°C`);
    
    // Calculate temperature change
    const tempChange = Math.abs(newData.temperature - oldData.temperature);
    
    // Only process significant changes (>= 3Â°C difference)
    if (tempChange >= 3) {
      await analysisQueue.add(
        'analyze-weather-change',
        {
          city: newData.city,
          country: newData.country,
          old_temperature: oldData.temperature,
          new_temperature: newData.temperature,
          change_magnitude: tempChange,
          change_type: newData.temperature > oldData.temperature ? 'increase' : 'decrease',
          significance_threshold: 3,
        },
        {
          priority: 1, // High priority for significant changes
          removeOnComplete: 15,
          removeOnFail: 3,
        }
      );
      
      res.status(200).json({ 
        success: true, 
        message: 'Significant weather change analysis queued',
        temperature_change: tempChange
      });
    } else {
      res.status(200).json({ 
        success: true, 
        message: 'Weather change not significant enough for analysis',
        temperature_change: tempChange,
        threshold: 3
      });
    }
  } catch (error) {
    console.error('Weather update webhook error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Webhook handler for real-time anomaly detection
app.post('/webhook/check-anomalies', async (req, res) => {
  try {
    const { event, table, op, data } = req.body;
    
    console.log(`ðŸ” Anomaly check triggered for ${table.name} table`);
    
    // Determine data type and symbol based on table
    let dataType, symbol;
    
    switch (table.name) {
      case 'weather_data':
        dataType = 'weather';
        symbol = data.new.city;
        break;
      case 'crypto_prices':
        dataType = 'crypto';
        symbol = data.new.symbol;
        break;
      case 'exchange_rates':
        dataType = 'currency';
        symbol = data.new.target_currency;
        break;
      default:
        throw new Error(`Unsupported table for anomaly detection: ${table.name}`);
    }
    
    // Queue real-time anomaly detection
    await analysisQueue.add(
      'real-time-anomaly-detection',
      {
        data_type: dataType,
        symbol: symbol,
        table_name: table.name,
        new_data: data.new,
        sensitivity: 2.0,
        window_size: 48, // Look at last 48 data points
        analysis_type: 'real-time',
        trigger_event: event.id,
      },
      {
        priority: 1,
        removeOnComplete: 5,
        removeOnFail: 2,
        attempts: 2,
      }
    );
    
    res.status(200).json({ 
      success: true, 
      message: 'Real-time anomaly detection queued',
      data_type: dataType,
      symbol: symbol
    });
  } catch (error) {
    console.error('Anomaly detection webhook error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Webhook handler for trend analysis triggers
app.post('/webhook/trend-analysis', async (req, res) => {
  try {
    const { event, table, op, data } = req.body;
    const analysisWindow = req.headers['x-analysis-window'] || '1h';
    
    console.log(`ðŸ“ˆ Trend analysis triggered for ${table.name} with ${analysisWindow} window`);
    
    // Queue trend analysis based on table type
    let analysisJobs = [];
    
    if (table.name === 'exchange_rates') {
      analysisJobs.push({
        name: 'currency-trend-analysis',
        data: {
          data_type: 'currency',
          base_currency: data.new.base_currency,
          target_currency: data.new.target_currency,
          analysis_window: analysisWindow,
          trigger_rate: data.new.rate,
          comparison_periods: ['1h', '4h', '24h'],
        }
      });
      
      // Also analyze major currency correlations
      if (['EUR', 'GBP', 'JPY'].includes(data.new.target_currency)) {
        analysisJobs.push({
          name: 'currency-correlation-analysis',
          data: {
            primary_currency: data.new.target_currency,
            correlation_targets: ['EUR', 'GBP', 'JPY'].filter(c => c !== data.new.target_currency),
            analysis_period: '24h',
            trigger_event: event.id,
          }
        });
      }
    }
    
    // Queue all analysis jobs
    for (const job of analysisJobs) {
      await analysisQueue.add(
        job.name,
        job.data,
        {
          delay: 2000, // Wait for related data updates
          removeOnComplete: 8,
          removeOnFail: 3,
        }
      );
    }
    
    res.status(200).json({ 
      success: true, 
      message: 'Trend analysis queued',
      jobs_queued: analysisJobs.length,
      analysis_window: analysisWindow
    });
  } catch (error) {
    console.error('Trend analysis webhook error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Webhook handler for data cleanup triggers
app.post('/webhook/cleanup-trigger', async (req, res) => {
  try {
    const { event, table, op, data } = req.body;
    
    console.log(`ðŸ§¹ Data cleanup triggered`);
    
    // Queue cleanup jobs for all data types
    const cleanupJobs = [
      {
        queue: weatherQueue,
        jobName: 'cleanup-old-weather',
        data: { olderThanDays: 30 }
      },
      {
        queue: currencyQueue,
        jobName: 'cleanup-old-rates',
        data: { olderThanDays: 90 }
      }
    ];
    
    for (const job of cleanupJobs) {
      await job.queue.add(
        job.jobName,
        job.data,
        {
          priority: 10, // Low priority
          removeOnComplete: 1,
          removeOnFail: 1,
          attempts: 2,
        }
      );
    }
    
    res.status(200).json({ 
      success: true, 
      message: 'Data cleanup jobs queued',
      jobs_queued: cleanupJobs.length
    });
  } catch (error) {
    console.error('Cleanup webhook error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    service: 'webhook-handlers',
    timestamp: new Date().toISOString(),
    queues: {
      weather: weatherQueue.name,
      currency: currencyQueue.name,
      analysis: analysisQueue.name,
    }
  });
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('Webhook handler error:', error);
  res.status(500).json({
    success: false,
    error: 'Internal server error',
    timestamp: new Date().toISOString()
  });
});

// Start the webhook server
const port = process.env.WEBHOOK_PORT || 3250;
app.listen(port, () => {
  console.log(`ðŸŽ£ Webhook handlers listening on port ${port}`);
  console.log(`ðŸ“¨ Available endpoints:`);
  console.log(`   POST /webhook/weather-inserted`);
  console.log(`   POST /webhook/crypto-inserted`);
  console.log(`   POST /webhook/exchange-rate-inserted`);
  console.log(`   POST /webhook/weather-updated`);
  console.log(`   POST /webhook/check-anomalies`);
  console.log(`   POST /webhook/trend-analysis`);
  console.log(`   POST /webhook/cleanup-trigger`);
  console.log(`   GET  /health`);
});

export default app;